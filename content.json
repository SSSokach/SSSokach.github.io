{"pages":[],"posts":[{"title":"Git学习笔记","text":"git大概是每个程序员必须要掌握的工具之一 常用 版本回退 避免重复劳动 分支 打包 本地与远程 常用git init ——初始化，创建git仓库git add filename ——添加文件git commit -m “日志说明” ——提交文件git log / git log –pretty=onelinegit reset –hard commit_id ——回滚到指定版本git reflog ——命令历史git checkout – filename ——工作区撤销，与暂存区相同git reset HEAD filename——暂存区file撤回到工作区git rm filename ——删除文件 版本回退HEAD指向的版本就是当前版本，因此，Git允许我们在版本的历史之间穿梭，使用命令git reset –soft/–mixed/–hard id回退，用git log可以查看提交历史重返未来，用git reflog查看命令历史 避免重复劳动在master分支上修复的bug，想要合并到当前dev分支，可以用git cherry-pick commit命令，把bug提交的修改“复制”到当前分支 分支查看分支：git branch创建分支：git branch name切换分支：git checkout name*或者git switch *name创建+切换分支：git checkout -b name*或者git switch -c *name合并某分支到当前分支：git merge name删除分支：git branch -d name分支合并图：git log –graph –pretty=oneline–pretty=oneline（将每条信息放在一行）###打包git stash 打包现场git stash list 查看stashgit stash pop 回到工作现场 本地与远程关联一个远程库git remote add origin git@server-name:path/repo-name.git；git push -u origin master第一次推送master分支的所有内容git push origin master此后推送最新修改从本地推送分支，使用git push origin branch-name，如果推送失败，先用git pull抓取远程的新提交；在本地创建和远程分支对应的分支，使用git checkout -b branch-name origin/branch-name，本地和远程分支的名称最好一致；建立本地分支和远程分支的关联，使用git branch –set-upstream branch-name origin/branch-name；从远程抓取分支，使用git pull，如果有冲突，要先处理冲突。","link":"/2020/03/07/Git%E5%AD%A6%E4%B9%A0/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. dadada","link":"/2020/03/07/hello-world/"},{"title":"icarus主题配置","text":"本文转载自CSDN:Hexo+icarus主题配置Hexo Icarus配置和美化升级 美化等进阶功能攻略位置：https://blog.csdn.net/marvine/article/details/89816846攻略位置：https://blog.csdn.net/qq_36759224/article/details/85420403#font_colorFF0000___font_289 目录 主题文件结构 主题配置 修改内容详细页 主题文件结构1234567891011/includes/languages #用来配置国际化语言版本，里边包含各种个配置像的文本翻译。/layout #以ejs文件来定义各种含有配置信息调用的布局（绝大多数修改点的位置）/scripts #一些JS脚本/source /css #用来修改自定义样式，需要掌握一定的css语法。 /fonts #定义字体文件，可以修改博客字体 /images #本地调用的图片放这里 /js #一些js脚本（特效.js存放处） /404.html #自定义的公益404页面/_config.yml #YML数据串行化格式语言书写的配置文件（首先修改） 主题配置_config.yml是主题的配置文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180version: 2.3.0# 你的网站图标，可以搜索在线图标制作，并将其放在images文件夹中favicon: /images/favicons.ico# Path or URL to RSS atom.xmlrss: /atom.xml# 显示在导航栏左侧的网站logo，同样可以自己制作logo: /images/gen.svg# Open Graph metadata# https://hexo.io/docs/helpers.html#open-graphopen_graph: # Facebook App ID fb_app_id: # Facebook Admin ID fb_admins: # Twitter ID twitter_id: # Twitter site twitter_site: # Google+ profile link google_plus: # 导航栏navbar: #菜单（显示名称：对应文件夹） menu: 主页: / 归档: /archives 分类: /categories 标签: /tags 关于: /about # 导航栏右侧图标链接 links: My GitHub: icon: fab fa-github url: '你的gityhub地址'# Footer section link settingsfooter: # 页脚图标链接 links: Creative Commons: icon: fab fa-creative-commons url: 'https://creativecommons.org/' Attribution 4.0 International: icon: fab fa-creative-commons-by url: 'https://creativecommons.org/licenses/by/4.0/' Download on GitHub: icon: fab fa-github url: 'http://github.com/ppoffice/hexo-theme-icarus'# 文章显示设置article: # Code highlight theme # https://github.com/highlightjs/highlight.js/tree/master/src/styles #代码主题atom-one-light亮色，atom-one-dark暗色 highlight: atom-one-dark # 是否显示文章主图 thumbnail: true # 是否显示估算阅读时间 readtime: true# 搜索插件设置# http://ppoffice.github.io/hexo-theme-icarus/categories/Configuration/Search-Pluginssearch: # Name of the search plugin type: insight# 评论插件设置# http://ppoffice.github.io/hexo-theme-icarus/categories/Configuration/Comment-Pluginscomment: #可选valine，disqus（科学上网）等 # Name of the comment plugin #type: valine #app_id: 不为空 #app_key: 不为空 #notify: true #verify: true #placeholder: type: disqus shortname: 不能为空# 打赏功能# http://ppoffice.github.io/hexo-theme-icarus/categories/Donation/donate: - # 阿里巴巴支付宝 type: alipay # 二维码图片 qrcode: '/images/honbao.PNG' - # 微信 type: wechat # 二维码图片 qrcode: '/images/yjtp.png' -# 分享插件设置# http://ppoffice.github.io/hexo-theme-icarus/categories/Configuration/Share-Pluginsshare: # 插件类型，有多种，可选，自行百度 type: sharejs# Sidebar settings.# Please be noted that a sidebar is only visible when it has at least one widgetsidebar: # 左侧边栏设置 left: # 是否不随页面滚动 # http://ppoffice.github.io/hexo-theme-icarus/Configuration/Theme/make-a-sidebar-sticky-when-page-scrolls/ sticky: false # 右侧边栏设置 right: # 是否不随页面滚动 # http://ppoffice.github.io/hexo-theme-icarus/Configuration/Theme/make-a-sidebar-sticky-when-page-scrolls/ sticky: false# 边栏小部件设置# http://ppoffice.github.io/hexo-theme-icarus/categories/Widgets/widgets: - # 个人信息 type: profile # 部件位置（左） position: left # 作者名（字符串） author: 飞鱼 # 作者身份描述（字符串） author_title: Student # 作者当前居住地 location: China,Fujian # 头像（可用本地图片或网络图片链接） avatar: '/images/ava.png' # Email address for the Gravatar to be shown in the profile widget gravatar: # 关注我的链接，可设为你的GitHub主页 follow_link: 'https://github.com/yourname' # 个人介绍部件底部图标社交链接 social_links: Github: icon: fab fa-github url: 'https://github.com/yourname' Facebook: icon: fab fa-facebook url: 'https://facebook.com' Twitter: icon: fab fa-twitter url: 'https://twitter.com/yourname' RSS: icon: fas fa-rss url: / - # Widget name type: toc # Where should the widget be placed, left or right position: left - # 分类 type: category # 位置指定 position: left - # 标签云 type: tagcloud # 位置 position: right - # 近期文章 type: recent_posts # 位置 position: left - # 归档 type: archive # Where should the widget be placed, left or right position: right - # 标签 type: tag # Where should the widget be placed, left or right position: right - # 外部链接 type: links # Where should the widget be placed, left or right position: left # Links to be shown in the links widget links: Google: 'https://google.com' Baidu: 'https://baidu.com' 修改内容详细页Hexo-icarus主题的文章详情页默认与主页布局一致，皆为三栏布局，想将其改为两栏布局。打开/themes/icarus/layout/layout.ejs文件，添加col()函数到文件中： 12345678&lt;% function col(){ if(!is_post()){ return main_column_class(); } else{ return 'is-6-tablet is-6-desktop is-9-widescreen'; } } %&gt; 再section标签中做如下改动： 12345678910&lt;section class=&quot;section&quot;&gt; &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;columns&quot;&gt; &lt;!-- 将main_column_class() 改为 col() --&gt; &lt;div class=&quot;column &lt;%= col() %&gt; has-order-2 column-main&quot;&gt;&lt;%- body %&gt;&lt;/div&gt; &lt;%- partial('common/widget', { position: 'left' }) %&gt; &lt;%- partial('common/widget', { position: 'right' }) %&gt; &lt;/div&gt; &lt;/div&gt; &lt;/section&gt; 不难看出，上述改动的目的是将显示逻辑改为：若当前页面不是文章页面则直接采用原始设置，否则将文章栏放大。通过上面的修改，hexo server查看效果，发现文章详情页的文章栏确实放大了，但是右侧的部件栏并未消失，而是被挤出了屏幕外一部分，极不美观。 为了解决上述问题，还需修改/themes/icarus/layout/common/widget.ejs文件。将代码全选复制，再粘贴于末尾，做如下修改3处代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172&lt;% if (get_widgets(position).length &amp;&amp; !is_post()) { %&gt; &lt;!-- 修改 --&gt;&lt;% function side_column_class() { switch (column_count()) { case 2: return 'is-4-tablet is-4-desktop is-4-widescreen'; case 3: return 'is-4-tablet is-4-desktop is-3-widescreen'; } return '';} %&gt;&lt;% function visibility_class() { if (column_count() === 3 &amp;&amp; position === 'right') { return 'is-hidden-touch is-hidden-desktop-only'; } return '';} %&gt;&lt;% function order_class() { return position === 'left' ? 'has-order-1' : 'has-order-3';} %&gt;&lt;% function sticky_class(position) { return get_config('sidebar.' + position + '.sticky', false) ? 'is-sticky' : '';} %&gt;&lt;div class=&quot;column &lt;%= side_column_class() %&gt; &lt;%= visibility_class() %&gt; &lt;%= order_class() %&gt; column-&lt;%= position %&gt; &lt;%= sticky_class(position) %&gt;&quot;&gt; &lt;% get_widgets(position).forEach(widget =&gt; {%&gt; &lt;%- partial('widget/' + widget.type, { widget, post: page }) %&gt; &lt;% }) %&gt; &lt;% if (position === 'left') { %&gt; &lt;div class=&quot;column-right-shadow is-hidden-widescreen &lt;%= sticky_class('right') %&gt;&quot;&gt; &lt;% get_widgets('right').forEach(widget =&gt; {%&gt; &lt;%- partial('widget/' + widget.type, { widget, post: page }) %&gt; &lt;% }) %&gt; &lt;/div&gt; &lt;% } %&gt;&lt;/div&gt;&lt;% } %&gt;&lt;!-- 粘贴的部分 --&gt;&lt;% if (position === 'left' &amp;&amp; is_post()) { %&gt; &lt;!-- 修改，可选保留的栏 --&gt;&lt;% function side_column_class() { switch (column_count()) { case 2: return 'is-4-tablet is-4-desktop is-4-widescreen'; case 3: return 'is-4-tablet is-4-desktop is-3-widescreen'; } return '';} %&gt;&lt;% function visibility_class() { if (column_count() === 3 &amp;&amp; position === 'right') { return 'is-hidden-touch is-hidden-desktop-only'; } return '';} %&gt;&lt;% function order_class() { return position === 'left' ? 'has-order-3' : 'has-order-1'; &lt;!-- 修改 --&gt;} %&gt;&lt;% function sticky_class(position) { return get_config('sidebar.' + position + '.sticky', false) ? 'is-sticky' : '';} %&gt;&lt;div class=&quot;column &lt;%= side_column_class() %&gt; &lt;%= visibility_class() %&gt; &lt;%= order_class() %&gt; column-&lt;%= position %&gt; &lt;%= sticky_class(position) %&gt;&quot;&gt; &lt;% get_widgets(position).forEach(widget =&gt; {%&gt; &lt;%- partial('widget/' + widget.type, { widget, post: page }) %&gt; &lt;% }) %&gt; &lt;% if (position === 'left') { %&gt; &lt;div class=&quot;column-right-shadow is-hidden-widescreen &lt;%= sticky_class('right') %&gt;&quot;&gt; &lt;% get_widgets('right').forEach(widget =&gt; {%&gt; &lt;%- partial('widget/' + widget.type, { widget, post: page }) %&gt; &lt;% }) %&gt; &lt;/div&gt; &lt;% } %&gt;&lt;/div&gt;&lt;% } %&gt;","link":"/2020/03/08/icarus%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/"},{"title":"hexo学习笔记","text":"","link":"/2020/03/07/hexo%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"title":"java笔记-反射与junit的结合应用","text":"软件构造第一次实验的FriendshipGraph需要自己写junit的测试，当需要测一个没有返回值的方法的时候（修改了类的变量），就需要用到反射机制来帮助测试。其实这实验我这样做就变得复杂了很多…..hhhhhh 获取class对象的方法 Class对象功能 field field [constructor](#constructor-function Object() { [native code] }1) method 举个这次实验的栗子 获取class对象的方法获取Class对象的方式： Class.forName(“全类名”)：将字节码文件加载进内存，返回Class对象 多用于配置文件，将类名定义在配置文件中。读取文件，加载类 类名.class：通过类名的属性class获取 多用于参数的传递 对象.getClass()：getClass()方法在Object类中定义着。 多用于对象的获取字节码的方式 Class对象功能 获取功能12345678getFields()：获得某个类的所有的公共（public）的字段，包括父类中的字段。 getDeclaredFields()：获得某个类的所有声明的字段，即包括public、private和proteced，但是不包括父类的申明字段。gitDeclaredField(String name):获得某个类的名为name的字段getConstructors()getDeclaredConstructors()getMethods()getDeclaredMethods() field 设置值void set(Object obj, Object value) 获取值get(Object obj) 忽略访问权限修饰符的安全检查setAccessible(true):当字段修饰符为private时，我们需要加上 constructor 创建对象：T newInstance(Object… initargs) 如果使用空参数构造方法创建对象，操作可以简化：Class对象的newInstance方法 ( jdk10已经不推荐使用了？ ) method 执行方法：Object invoke(Object obj, Object… args) 获取方法名称：String getName:获取方法名 举个这次实验的栗子1234567891011public class Person { private String name; private List&lt;Person&gt; friends; public Person(String name) { this.name = name; this.friends=new ArrayList&lt;Person&gt;(); } public void addFriend(Person friend) { friends.add(friend); }} 下面，测试addFriend 123456789101112131415Person rachel = new Person(\"Rachel\");Person ross = new Person(\"Ross\");Person ben = new Person(\"Ben\");List&lt;Person&gt; testfriends=new ArrayList&lt;Person&gt;();testfriends.add(ross);testfriends.add(ben);rachel.addFriend(ross);rachel.addFriend(ben);Class personClass=Person.class;Field fieldfriends=personClass.getDeclaredField(\"friends\");fieldfriends.setAccessible(true);//忽略封装assertEquals(rachelfriends, fieldfriends.get(rachel));//重点！！ 这样，就完成了对addFriend的测试","link":"/2020/03/08/java%E5%8F%8D%E5%B0%84+junit/"}],"tags":[{"name":"Git","slug":"Git","link":"/tags/Git/"},{"name":"软件构造","slug":"软件构造","link":"/tags/%E8%BD%AF%E4%BB%B6%E6%9E%84%E9%80%A0/"},{"name":"hexo","slug":"hexo","link":"/tags/hexo/"},{"name":"转载","slug":"转载","link":"/tags/%E8%BD%AC%E8%BD%BD/"},{"name":"java笔记","slug":"java笔记","link":"/tags/java%E7%AC%94%E8%AE%B0/"}],"categories":[]}
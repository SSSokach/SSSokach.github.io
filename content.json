{"pages":[],"posts":[{"title":"Git学习笔记","text":"git大概是每个程序员必须要掌握的工具之一 常用 版本回退 避免重复劳动 分支 打包 本地与远程 常用git init ——初始化，创建git仓库git add filename ——添加文件git commit -m “日志说明” ——提交文件git log / git log –pretty=onelinegit reset –hard commit_id ——回滚到指定版本git reflog ——命令历史git checkout – filename ——工作区撤销，与暂存区相同git reset HEAD filename——暂存区file撤回到工作区git rm filename ——删除文件 版本回退HEAD指向的版本就是当前版本，因此，Git允许我们在版本的历史之间穿梭，使用命令git reset –soft/–mixed/–hard id回退，用git log可以查看提交历史重返未来，用git reflog查看命令历史 避免重复劳动在master分支上修复的bug，想要合并到当前dev分支，可以用git cherry-pick commit命令，把bug提交的修改“复制”到当前分支 分支查看分支：git branch创建分支：git branch name切换分支：git checkout name*或者git switch *name创建+切换分支：git checkout -b name*或者git switch -c *name合并某分支到当前分支：git merge name删除分支：git branch -d name 查看分支图git log –graph –decorate –oneline –simplify-by-decoration –all说明：–decorate 标记会让git log显示每个commit的引用(如:分支、tag等)–oneline 一行显示–simplify-by-decoration 只显示被branch或tag引用的commit–all 表示显示所有的branch，这里也可以选择，比如我指向显示分支ABC的关系，则将–all替换为branchA branchB branchC###打包git stash 打包现场git stash list 查看stashgit stash pop 回到工作现场 本地与远程关联一个远程库git remote add origin git@server-name:path/repo-name.git；git push -u origin master第一次推送master分支的所有内容git push origin master此后推送最新修改从本地推送分支，使用git push origin branch-name，如果推送失败，先用git pull抓取远程的新提交；在本地创建和远程分支对应的分支，使用git checkout -b branch-name origin/branch-name，本地和远程分支的名称最好一致；建立本地分支和远程分支的关联，使用git branch –set-upstream branch-name origin/branch-name；从远程抓取分支，使用git pull，如果有冲突，要先处理冲突。","link":"/2020/03/07/Git%E5%AD%A6%E4%B9%A0/"},{"title":"hexo学习笔记","text":"用hexo+github搭建完了自己这个特别特别简陋的博客，这篇是最近学到的hexo和markdown的用法 命令行 插入图片- [绝对路径](#绝对路径) - [相对路径](#相对路径) 标签插件（Tag Plugins） 模板设置 命令行hexo new draft name—-创建名为name的草稿hexo publish draft name—-移动到_post里/发表 插入图片绝对路径当Hexo项目中只用到少量图片时，可以将图片统一放在source/images文件夹中，通过markdown语法访问它们。 ![](/images/image.jpg)相对路径图片除了可以放在统一的images文件夹中，还可以放在文章自己的目录中。文章的目录可以通过配置_config.yml来生成。 post_asset_folder: true 之后，执行命令$ hexo new post_name，在source/_posts中会生成文章post_name.md和同名文件夹post_name。将图片资源放在post_name中，文章就可以使用相对路径引用图片资源了。 ![](image.jpg) 标签插件（Tag Plugins）标签插件和 Front-matter 中的标签不同，它们是用于在文章中快速插入特定内容的插件。 &lt;!--more--&gt;——–read more 123{% blockquote %}内容{% endblockquote %} ——–普通blockquote 123{% blockquote 书名, 作者 %}内容{% endblockquote %} ——–引用书本的blockquote 模板设置当我们使用命令 hexo new “title” 创建文章时，Hexo 会根据 /scaffolds/post.md 对新文章进行初始化 换言之，/scaffolds/post.md 就是新文章的 模板，所以我们可以修改它来适应自己的写作习惯 一个简单的示例如下： 1234title: {{ title }}date: {{ date }}tags: categories: 属性和属性值之间必须有一个空格，否则会解析错误","link":"/2020/03/06/hexo%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"title":"java关于集合类的一点点探索","text":"对set集合的contains函数的运行机制有一点点小疑问以及探索 问题123456789//保证了a，b指向两个ID不同，内容相同的字符串String a=new String(\"v1\");String b=new String(\"v1\");HashSet&lt;String&gt; set=new HashSet&lt;String&gt;();set.add(a);System.out.println(set.contains(b));//结果true a,b两个String类指向的对象，id不同，内容相同，contains是如何判断这两个对象相同的？最开始以为是和equals方法有关系，于是做了一个小测试 123456789101112//简单的car类public class car { private String name;}//mainHashSet&lt;car&gt; s=new HashSet&lt;car&gt;();car a=new car(\"car1\");car b=new car(\"car1\");s.add(a);System.out.println(s.contains(b));//结果false 结果显然是false于是重写了car的equals方法（右键自动生成的。。。） 12345678910111213141516@Overridepublic boolean equals(Object obj) { if (this == obj) return true; if (obj == null) return false; if (getClass() != obj.getClass()) return false; car other = (car) obj; if (name == null) { if (other.name != null) return false; } else if (!name.equals(other.name)) return false; return true;} 但是运行main函数仍然显示false 看源码一层一层的找往里找 12345private transient HashMap&lt;E,Object&gt; map;//HashSet的contains方法public boolean contains(Object o) { return map.containsKey(o); } （害！HashSet其实是用HashMap实现的啊） 1234//HashMappublic boolean containsKey(Object key) { return getNode(hash(key), key) != null; } 1234static final int hash(Object key) { int h; return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);} 12345678910111213141516171819final Node&lt;K,V&gt; getNode(int hash, Object key) { Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k; if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp; (first = tab[(n - 1) &amp; hash]) != null) { if (first.hash == hash &amp;&amp; // always check firstnode ((k = first.key) == key || (key != null &amp;&amp;key.equals(k)))) return first; if ((e = first.next) != null) { if (first instanceof TreeNode) return ((TreeNode&lt;K,V&gt;)first).getTreeNod(hash, key); do { if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp; key.equals(k)))) return e; } while ((e = e.next) != null); } } return null;} 最终getNode方法里面找到了答案(4,5行)1.判断两个对象hashcode是否相同,2.判断两个对象是否“相同” （a==b||a.equals(b)) 解决问题回头再来看car类尝试看一下两个对象的哈希值是否一样 1234567car a=new car(\"car1\");car b=new car(\"car1\");System.out.println(b.hashCode());System.out.println(a.hashCode());//结果13110531352018699554 所以问题就在此，重写一下hashcode方法试试(之前已经重写了equals方法) 1234567@Overridepublic int hashCode() { final int prime = 31; int result = 1; result = prime * result + ((name == null) ? 0 : name.hashCode()); return result;} 再来测试car类 12345678System.out.println(b.hashCode());System.out.println(a.hashCode());s.add(a);System.out.println(s.contains(b));//结果30461403046140true 总结HashSet的contains判断两对象相同的方法：1.判断两个对象hashcode是否相同,2.判断两个对象是否“相同” （a==b||a.equals(b)) 所以！为正在使用的类重写hashCode和equals方法即可。","link":"/2020/03/20/java%E5%85%B3%E4%BA%8E%E9%9B%86%E5%90%88%E7%B1%BB%E7%9A%84%E4%B8%80%E7%82%B9%E7%82%B9%E6%8E%A2%E7%B4%A2/"},{"title":"Python通过对象名调用方法（对象名后加括号和参数）","text":"提前一周写完软件构造实验，hhh，打算把python捡一捡然后网上一个例子给看懵了 model = MNIST() # 声明一个对象 a = model(b) # 用对象去调用方法????????小朋友你是不是有很多问号？ 一顿搜索发现其实原因就在于这个类实现了call()方法 可调用对象可调用对象（callable），我们平时自定义的函数、内置函数和类都属于可调用对象，但凡是可以把一对括号()应用到某个对象身上都可称之为可调用对象，判断对象是否为可调用对象可以用函数 callable 如果在类中实现了 __call__ 方法，那么实例对象也将成为一个可调用对象， 举个栗子： 12345678910111213class Entity:'''调用实体来改变实体的位置。'''def __init__(self, size, x, y): self.x, self.y = x, y self.size = sizedef __call__(self, x, y): '''改变实体的位置''' self.x, self.y = x, ye = Entity(1, 2, 3) // 创建实例e(4, 5) //实例可以象函数那样执行，并传入x y值，修改对象的x y e(4,5)本质其实是e.__call__(4,5)所以 __call__ 在那些类的实例经常改变状态的时候会非常有效。更多厉害的用法可以参考Python call详解","link":"/2020/04/08/Python%E9%80%9A%E8%BF%87%E5%AF%B9%E8%B1%A1%E5%90%8D%E8%B0%83%E7%94%A8%E6%96%B9%E6%B3%95%EF%BC%88%E5%AF%B9%E8%B1%A1%E5%90%8D%E5%90%8E%E5%8A%A0%E6%8B%AC%E5%8F%B7%E5%92%8C%E5%8F%82%E6%95%B0%EF%BC%89/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. dadada","link":"/2020/03/07/hello-world/"},{"title":"java反射与junit的结合应用","text":"软件构造第一次实验的FriendshipGraph需要自己写junit的测试，当需要测一个没有返回值的方法的时候（修改了类的变量），就需要用到反射机制来帮助测试。其实这实验我这样做就变得复杂了很多…..hhhhhh 获取class对象的方法 Class对象功能 field field constructor method 举个这次实验的栗子 获取class对象的方法获取Class对象的方式： Class.forName(“全类名”)：将字节码文件加载进内存，返回Class对象 多用于配置文件，将类名定义在配置文件中。读取文件，加载类 类名.class：通过类名的属性class获取 多用于参数的传递 对象.getClass()：getClass()方法在Object类中定义着。 多用于对象的获取字节码的方式 Class对象功能 获取功能12345678getFields()：获得某个类的所有的公共（public）的字段，包括父类中的字段。 getDeclaredFields()：获得某个类的所有声明的字段，即包括public、private和proteced，但是不包括父类的申明字段。gitDeclaredField(String name):获得某个类的名为name的字段getConstructors()getDeclaredConstructors()getMethods()getDeclaredMethods() field 设置值void set(Object obj, Object value) 获取值get(Object obj) 忽略访问权限修饰符的安全检查setAccessible(true):当字段修饰符为private时，我们需要加上 constructor 创建对象：T newInstance(Object… initargs) 如果使用空参数构造方法创建对象，操作可以简化：Class对象的newInstance方法 ( jdk10已经不推荐使用了？ ) method 执行方法：Object invoke(Object obj, Object… args) 获取方法名称：String getName:获取方法名 举个这次实验的栗子1234567891011public class Person { private String name; private List&lt;Person&gt; friends; public Person(String name) { this.name = name; this.friends=new ArrayList&lt;Person&gt;(); } public void addFriend(Person friend) { friends.add(friend); }} 下面，测试addFriend 123456789101112131415Person rachel = new Person(\"Rachel\");Person ross = new Person(\"Ross\");Person ben = new Person(\"Ben\");List&lt;Person&gt; testfriends=new ArrayList&lt;Person&gt;();testfriends.add(ross);testfriends.add(ben);rachel.addFriend(ross);rachel.addFriend(ben);Class personClass=Person.class;Field fieldfriends=personClass.getDeclaredField(\"friends\");fieldfriends.setAccessible(true);//忽略封装assertEquals(rachelfriends, fieldfriends.get(rachel));//重点！！ 这样，就完成了对addFriend的测试","link":"/2020/03/08/java%E5%8F%8D%E5%B0%84+junit/"},{"title":"java文件读写","text":"软件构造lab1中遇到了文件读写的问题，自己用的一种简单的相对寻址的方法，但是健壮性不足，只要文件改变位置，就会报错。在和同学讨论的时候发现了更好的方法，故记录在这里，方便查看 用软件构造的lab1目录结构举例：Lab1-XXX|– src|—|– P1|—|—|-&gt; MagicSquare.java|—|—|– txt|—|—|—|-&gt; 1.txt|—|—|—|-&gt; 2.txt|—|—|—|-&gt; …|—|—|—|-&gt; 5.txt eclipse的相对路径是相对.project而言的！！！ 一般路径最好写成 / /等价于\\\\ 例：D:/test/main.java 基本方法//Java7的try-with-resources可以优雅关闭文件，异常时自动关闭文件；详细解读https://stackoverflow.com/a/12665271 读取文件12345678910111213String pathname = \"src/P1/txt/1.txt\";public boolean isLegalMagicSquare() {try(BufferedReader input=new BufferedReader( new FileReader(pathname))) { String line; while ((line = input.readLine()) != null) { // 一次读入一行数据 System.out.println(line); } } catch (IOException e) { e.printStackTrace(); }} 写入文件12345678910111213141516171819202122//方法1String pathname = \"src/P1/txt/1.txt\";public static void writeFile() { try { File writeName = new File(pathname); writeName.createNewFile(); // 创建新文件,有同名的文件的话直接覆盖 try (PrintWriter out=new PrintWriter( new FileWriter(writeName)) ) { out.println(\"方法1\"); // \\r\\n即为换行 } } catch (IOException e) { e.printStackTrace(); } }//方法2BufferedWriter out=new BufferedWriter( new FileWriter(writeName))out.write(\"方法1\\r\\n\"); // \\r\\n即为换行out.write(\"hhhh\\r\\n\"); // \\r\\n即为换行out.flush(); // 把缓存区内容压入文件 下面有三个进阶一丢丢的方法，也许可以帮助改进你的代码 改进1使用System.getProperty(&quot;key&quot;) key . user.name 用户的账户名称 user.home 用户的主目录 user.dir 用户的当前工作目录 12345String path1=System.getProperty(\"user.dir\");System.out.println(path1);输出:D:\\JavaWorkPlace\\test 改进2查询某类的.class文件所在目录 1234567891011String path1=MagicSquare.class.getResource(\"\").getPath();String path2=MagicSquare.class.getResource(\"/\").getPath();String path3=MagicSquare.class.getResource(\"/P1/txt\").getPath();System.out.println(path1);System.out.println(path2);System.out.println(path3);输出：/D:/JavaWorkPlace/test/bin/P1//D:/JavaWorkPlace/test/bin//D:/JavaWorkPlace/test/bin/P1/txt //前提这个文件夹得存在 改进3 查询某类的classloader所在目录 12345String path1=MagicSquare.class.getClassLoader().getResource(\"\").getPath();System.out.println(path1);输出：/D:/JavaWorkPlace/test/bin/","link":"/2020/03/13/java%E6%96%87%E4%BB%B6%E8%AF%BB%E5%86%99/"},{"title":"java父类子类初始化顺序","text":"由Cannot reference 'FlightScheduleApp.sources' before supertype constructor has been called引发的思考 问题123456789101112131415161718192021public class BaseApp&lt;S,E&gt; { private final List&lt;S&gt; sources; private final List&lt;Location&gt; locations; private final List&lt;E&gt; entries; public BaseApp(List&lt;S&gt; sources, List&lt;Location&gt; locations, List&lt;E&gt; entries) { this.sources = sources; this.locations = locations; this.entries = entries; }}public class FlightScheduleApp extends BaseApp&lt;Plane, FlightEntry&gt; { private final List&lt;Plane&gt; sources=new ArrayList&lt;&gt;(); private final List&lt;Location&gt; locations=new ArrayList&lt;&gt;(); private final List&lt;FlightEntry&gt; entries=new ArrayList&lt;&gt;(); public FlightScheduleApp() { //Cannot reference 'FlightScheduleApp.sources' before supertype constructor has been called super(sources,locations,entries); }} 意思是在父类构函数初始化之前不能引用这个变量。 解决办法在子类这个变量前加上startic修饰符时，就不再报错。 猜想验证1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/** * 父类 */public class Base { static String sVar = getString(\"父类静态变量初始化\"); public String var = getString(\"父类非静态变量初始化\"); public Base() { System.out.println(\"父类构造函数 start\"); draw(\"父类调用draw方法\");//会调用子类覆盖后的方法，这里是null System.out.println(\"父类构造函数 end\"); } static String getString(String base) { System.out.println(base); return base; } public void draw(String string) { System.out.println(string); }}/** * 子类 */public class SubClass extends Base { public String var = getString(\"子类非静态变量初始化\"); private String subVar = getString(\"子类私有变量初始化\"); static String superVar = getString(\"子类静态变量初始化\"); SubClass() { System.out.println(\"子类构造函数start\"); draw(\"子类调用draw方法\"); System.out.println(\"子类构造函数end\"); } public void draw(String string) { System.out.println(string + subVar); } public static void main(String[] args) { new SubClass(); }} 结果 1234567891011父类静态变量初始化子类静态变量初始化 &lt;-----父类非静态变量初始化 &lt;-----父类构造函数 start父类调用draw方法null父类构造函数 end子类非静态变量初始化 &lt;-----子类私有变量初始化子类构造函数start子类调用draw方法子类初始化私有变量子类构造函数end 可以发现，父类构造函数初始化早于子类非静态变量的初始化，晚于子类静态变量的初始化,所以当我们需要把变量改为static","link":"/2020/04/24/java%E7%88%B6%E7%B1%BB%E5%AD%90%E7%B1%BB%E5%88%9D%E5%A7%8B%E5%8C%96%E9%A1%BA%E5%BA%8F/"},{"title":"最大子数组问题","text":"算法导论第四章分治的第一个例题：最大子数组问题 $O(n^2)$暴力算法 $O(nlogn)$分治算法将数组array[low..high]分为array[low..mid]，array[mid+1..high]最大子数组array[i..j]所在位置必然在如下三种情况里：1.完全位于array[low..mid]2.完全位于array[mid+1..high]3.跨越mid （low&lt;i&lt;mid&lt;j&lt;high) 1,2为重复子问题3即寻找i，j使array[i..mid]，array[mid+1..j]分别最大 ： O(n)级别 递归方程：$$T(n)=2*T(n/2)+O(n)$$复杂度即$O(nlogn)$ $O(n)$线性算法推荐一个非常棒的博客：最大子数组的和问题–线性算法","link":"/2020/03/17/%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84%E9%97%AE%E9%A2%98/"},{"title":"icarus主题配置","text":"本文转载自CSDN:Hexo+icarus主题配置Hexo Icarus配置和美化升级 美化等进阶功能攻略位置：https://blog.csdn.net/marvine/article/details/89816846攻略位置：https://blog.csdn.net/qq_36759224/article/details/85420403#font_colorFF0000___font_289 目录 主题文件结构 主题配置 修改内容详细页 添加网站访问量因为目前搭的博客是静态网页，所以添加网站访问量需要用到第三方工具具体见:不蒜子:搞定你的网站计数 主题文件结构1234567891011/includes/languages #用来配置国际化语言版本，里边包含各种个配置像的文本翻译。/layout #以ejs文件来定义各种含有配置信息调用的布局（绝大多数修改点的位置）/scripts #一些JS脚本/source /css #用来修改自定义样式，需要掌握一定的css语法。 /fonts #定义字体文件，可以修改博客字体 /images #本地调用的图片放这里 /js #一些js脚本（特效.js存放处） /404.html #自定义的公益404页面/_config.yml #YML数据串行化格式语言书写的配置文件（首先修改） 主题配置_config.yml是主题的配置文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180version: 2.3.0# 你的网站图标，可以搜索在线图标制作，并将其放在images文件夹中favicon: /images/favicons.ico# Path or URL to RSS atom.xmlrss: /atom.xml# 显示在导航栏左侧的网站logo，同样可以自己制作logo: /images/gen.svg# Open Graph metadata# https://hexo.io/docs/helpers.html#open-graphopen_graph: # Facebook App ID fb_app_id: # Facebook Admin ID fb_admins: # Twitter ID twitter_id: # Twitter site twitter_site: # Google+ profile link google_plus: # 导航栏navbar: #菜单（显示名称：对应文件夹） menu: 主页: / 归档: /archives 分类: /categories 标签: /tags 关于: /about # 导航栏右侧图标链接 links: My GitHub: icon: fab fa-github url: '你的gityhub地址'# Footer section link settingsfooter: # 页脚图标链接 links: Creative Commons: icon: fab fa-creative-commons url: 'https://creativecommons.org/' Attribution 4.0 International: icon: fab fa-creative-commons-by url: 'https://creativecommons.org/licenses/by/4.0/' Download on GitHub: icon: fab fa-github url: 'http://github.com/ppoffice/hexo-theme-icarus'# 文章显示设置article: # Code highlight theme # https://github.com/highlightjs/highlight.js/tree/master/src/styles #代码主题atom-one-light亮色，atom-one-dark暗色 highlight: atom-one-dark # 是否显示文章主图 thumbnail: true # 是否显示估算阅读时间 readtime: true# 搜索插件设置# http://ppoffice.github.io/hexo-theme-icarus/categories/Configuration/Search-Pluginssearch: # Name of the search plugin type: insight# 评论插件设置# http://ppoffice.github.io/hexo-theme-icarus/categories/Configuration/Comment-Pluginscomment: #可选valine，disqus（科学上网）等 # Name of the comment plugin #type: valine #app_id: 不为空 #app_key: 不为空 #notify: true #verify: true #placeholder: type: disqus shortname: 不能为空# 打赏功能# http://ppoffice.github.io/hexo-theme-icarus/categories/Donation/donate: - # 阿里巴巴支付宝 type: alipay # 二维码图片 qrcode: '/images/honbao.PNG' - # 微信 type: wechat # 二维码图片 qrcode: '/images/yjtp.png' -# 分享插件设置# http://ppoffice.github.io/hexo-theme-icarus/categories/Configuration/Share-Pluginsshare: # 插件类型，有多种，可选，自行百度 type: sharejs# Sidebar settings.# Please be noted that a sidebar is only visible when it has at least one widgetsidebar: # 左侧边栏设置 left: # 是否不随页面滚动 # http://ppoffice.github.io/hexo-theme-icarus/Configuration/Theme/make-a-sidebar-sticky-when-page-scrolls/ sticky: false # 右侧边栏设置 right: # 是否不随页面滚动 # http://ppoffice.github.io/hexo-theme-icarus/Configuration/Theme/make-a-sidebar-sticky-when-page-scrolls/ sticky: false# 边栏小部件设置# http://ppoffice.github.io/hexo-theme-icarus/categories/Widgets/widgets: - # 个人信息 type: profile # 部件位置（左） position: left # 作者名（字符串） author: 飞鱼 # 作者身份描述（字符串） author_title: Student # 作者当前居住地 location: China,Fujian # 头像（可用本地图片或网络图片链接） avatar: '/images/ava.png' # Email address for the Gravatar to be shown in the profile widget gravatar: # 关注我的链接，可设为你的GitHub主页 follow_link: 'https://github.com/yourname' # 个人介绍部件底部图标社交链接 social_links: Github: icon: fab fa-github url: 'https://github.com/yourname' Facebook: icon: fab fa-facebook url: 'https://facebook.com' Twitter: icon: fab fa-twitter url: 'https://twitter.com/yourname' RSS: icon: fas fa-rss url: / - # Widget name type: toc # Where should the widget be placed, left or right position: left - # 分类 type: category # 位置指定 position: left - # 标签云 type: tagcloud # 位置 position: right - # 近期文章 type: recent_posts # 位置 position: left - # 归档 type: archive # Where should the widget be placed, left or right position: right - # 标签 type: tag # Where should the widget be placed, left or right position: right - # 外部链接 type: links # Where should the widget be placed, left or right position: left # Links to be shown in the links widget links: Google: 'https://google.com' Baidu: 'https://baidu.com' 修改内容详细页Hexo-icarus主题的文章详情页默认与主页布局一致，皆为三栏布局，想将其改为两栏布局。打开/themes/icarus/layout/layout.ejs文件，添加col()函数到文件中： 12345678&lt;% function col(){ if(!is_post()){ return main_column_class(); } else{ return 'is-6-tablet is-6-desktop is-9-widescreen'; } } %&gt; 再section标签中做如下改动： 12345678910&lt;section class=&quot;section&quot;&gt; &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;columns&quot;&gt; &lt;!-- 将main_column_class() 改为 col() --&gt; &lt;div class=&quot;column &lt;%= col() %&gt; has-order-2 column-main&quot;&gt;&lt;%- body %&gt;&lt;/div&gt; &lt;%- partial('common/widget', { position: 'left' }) %&gt; &lt;%- partial('common/widget', { position: 'right' }) %&gt; &lt;/div&gt; &lt;/div&gt; &lt;/section&gt; 不难看出，上述改动的目的是将显示逻辑改为：若当前页面不是文章页面则直接采用原始设置，否则将文章栏放大。通过上面的修改，hexo server查看效果，发现文章详情页的文章栏确实放大了，但是右侧的部件栏并未消失，而是被挤出了屏幕外一部分，极不美观。 为了解决上述问题，还需修改/themes/icarus/layout/common/widget.ejs文件。将代码全选复制，再粘贴于末尾，做如下修改3处代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172&lt;% if (get_widgets(position).length &amp;&amp; !is_post()) { %&gt; &lt;!-- 修改 --&gt;&lt;% function side_column_class() { switch (column_count()) { case 2: return 'is-4-tablet is-4-desktop is-4-widescreen'; case 3: return 'is-4-tablet is-4-desktop is-3-widescreen'; } return '';} %&gt;&lt;% function visibility_class() { if (column_count() === 3 &amp;&amp; position === 'right') { return 'is-hidden-touch is-hidden-desktop-only'; } return '';} %&gt;&lt;% function order_class() { return position === 'left' ? 'has-order-1' : 'has-order-3';} %&gt;&lt;% function sticky_class(position) { return get_config('sidebar.' + position + '.sticky', false) ? 'is-sticky' : '';} %&gt;&lt;div class=&quot;column &lt;%= side_column_class() %&gt; &lt;%= visibility_class() %&gt; &lt;%= order_class() %&gt; column-&lt;%= position %&gt; &lt;%= sticky_class(position) %&gt;&quot;&gt; &lt;% get_widgets(position).forEach(widget =&gt; {%&gt; &lt;%- partial('widget/' + widget.type, { widget, post: page }) %&gt; &lt;% }) %&gt; &lt;% if (position === 'left') { %&gt; &lt;div class=&quot;column-right-shadow is-hidden-widescreen &lt;%= sticky_class('right') %&gt;&quot;&gt; &lt;% get_widgets('right').forEach(widget =&gt; {%&gt; &lt;%- partial('widget/' + widget.type, { widget, post: page }) %&gt; &lt;% }) %&gt; &lt;/div&gt; &lt;% } %&gt;&lt;/div&gt;&lt;% } %&gt;&lt;!-- 粘贴的部分 --&gt;&lt;% if (position === 'left' &amp;&amp; is_post()) { %&gt; &lt;!-- 修改，可选保留的栏 --&gt;&lt;% function side_column_class() { switch (column_count()) { case 2: return 'is-4-tablet is-4-desktop is-4-widescreen'; case 3: return 'is-4-tablet is-4-desktop is-3-widescreen'; } return '';} %&gt;&lt;% function visibility_class() { if (column_count() === 3 &amp;&amp; position === 'right') { return 'is-hidden-touch is-hidden-desktop-only'; } return '';} %&gt;&lt;% function order_class() { return position === 'left' ? 'has-order-3' : 'has-order-1'; &lt;!-- 修改 --&gt;} %&gt;&lt;% function sticky_class(position) { return get_config('sidebar.' + position + '.sticky', false) ? 'is-sticky' : '';} %&gt;&lt;div class=&quot;column &lt;%= side_column_class() %&gt; &lt;%= visibility_class() %&gt; &lt;%= order_class() %&gt; column-&lt;%= position %&gt; &lt;%= sticky_class(position) %&gt;&quot;&gt; &lt;% get_widgets(position).forEach(widget =&gt; {%&gt; &lt;%- partial('widget/' + widget.type, { widget, post: page }) %&gt; &lt;% }) %&gt; &lt;% if (position === 'left') { %&gt; &lt;div class=&quot;column-right-shadow is-hidden-widescreen &lt;%= sticky_class('right') %&gt;&quot;&gt; &lt;% get_widgets('right').forEach(widget =&gt; {%&gt; &lt;%- partial('widget/' + widget.type, { widget, post: page }) %&gt; &lt;% }) %&gt; &lt;/div&gt; &lt;% } %&gt;&lt;/div&gt;&lt;% } %&gt;","link":"/2020/03/08/icarus%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/"},{"title":"试一试自动上传到图床的功能","text":"try","link":"/2020/05/07/%E8%AF%95%E4%B8%80%E8%AF%95%E8%87%AA%E5%8A%A8%E4%B8%8A%E4%BC%A0%E5%88%B0%E5%9B%BE%E5%BA%8A%E7%9A%84%E5%8A%9F%E8%83%BD/"},{"title":"正则表达式","text":"正则表达式初学 .1. 正则表达式 .1.1. 非打印字符 .1.2. 特殊符 .1.3. 限定符 .1.4. 定位符 .1.5. 高级 .1.6. 在java中的特殊点 .1.7. 常用表达式 .1.8. 两个例子 .1.1. 非打印字符 特别字符 描述 \\f 匹配一个换页符。等价于 \\x0c 和 \\cL。 \\n 匹配一个换行符。等价于 \\x0a 和 \\cJ。 \\r 匹配一个回车符。等价于 \\x0d 和 \\cM。 \\s 匹配任何空白字符，包括空格、制表符、换页符等等。等价于[ \\f\\n\\r\\t\\v]。注意 Unicode 正则表达式会匹配全角空格符。 \\S 匹配任何非空白字符。等价于 [^ \\f\\n\\r\\t\\v]。 \\t 匹配一个制表符。等价于 \\x09 和 \\cI。 \\v 匹配一个垂直制表符。等价于 \\x0b 和 \\cK。 \\w 匹配字母或数字或下划线或汉字 等价于 [^A-Za-z0-9_] \\d 匹配数字 \\D 匹配非数字 .1.2. 特殊符 符号 含义 . 除\\n以外任意字符 ^ 当该符号在方括号表达式中使用时，表示不接受该方括号表达式中的字符集合 | 二选一 .1.3. 限定符1234567891011*+？{n}{n,}{n,m} 其中* +为贪婪的,会尽可能多的匹配字符 例: 匹配&lt;h1&gt;不啦不啦不啦&lt;/h1&gt; 匹配结果 &lt;.*&gt; 贪婪 不啦不啦不啦 &lt;.*?&gt; 非贪婪 .1.4. 定位符 字符 描述 ^ 匹配输入字符串开始的位置。如果设置了 RegExp 对象的 Multiline 属性，^ 还会与 \\n 或 \\r 之后的位置匹配。 $ 匹配输入字符串结尾的位置。如果设置了 RegExp 对象的 Multiline 属性，$ 还会与 \\n 或 \\r 之前的位置匹配。 \\b 匹配一个单词边界，即字与空格间的位置。 \\B 非单词边界匹配。 注:若要匹配一行文本开始处的文本，请在正则表达式的开始使用 ^ 字符。不要将 ^ 的这种用法与中括号表达式内的用法混淆。 若要匹配一行文本的结束处的文本，请在正则表达式的结束处使用 $ 字符。 例 Chapter RegExp 匹配章节标题 ^Chapter [1-9][0-9]{0,1}$ 匹配单词开头 \\bCha 匹配结尾 ter\\b 匹配中间字符 \\Bapt 但无法匹配apter(开头) .1.5. 高级 字符 描述 (pattern) 匹配 pattern 并获取这一匹配。所获取的匹配可以从产生的 Matches 集合得到，在VBScript 中使用 SubMatches 集合，在JScript 中则使用 $0…$9 属性。要匹配圆括号字符，请使用 ‘(‘ 或 ‘)‘。 (?:pattern) 匹配 pattern 但不获取匹配结果，也就是说这是一个非获取匹配，不进行存储供以后使用。这在使用 “或” 字符 (|) 来组合一个模式的各个部分是很有用。例如，industr(?:y|ies) 就是一个比 industry|industries更简略的表达式。 (?=pattern) 正向肯定预查（look ahead positive assert），在任何匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如，Windows(?=95|98|NT|2000)能匹配Windows2000中的Windows，但不能匹配Windows3.1中的Windows。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。 (?!pattern) 正向否定预查(negative assert)，在任何不匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如Windows(?!95|98|NT|2000)能匹配Windows3.1中的Windows，但不能匹配Windows2000中的Windows。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。 (?&lt;=pattern) 反向(look behind)肯定预查，与正向肯定预查类似，只是方向相反。例如，”`(?&lt;=95 (?&lt;!pattern) 反向否定预查，与正向否定预查类似，只是方向相反。例如”(?”能匹配”3.1Windows“中的”Windows“，但不能匹配”2000Windows“中的”Windows“。 .1.6. 在java中的特殊点在其他语言中（如Perl），\\\\ 表示：我想要在正则表达式中插入一个普通的（字面上的）反斜杠，请不要给它任何特殊的意义。 在 Java 中，\\\\ 表示：我要插入一个正则表达式的反斜线，所以其后的字符具有特殊的意义。 所以，在其他的语言中（如Perl），一个反斜杠\\ 就足以具有转义的作用，而在 Java 中正则表达式中则需要有两个反斜杠才能被解析为其他语言中的转义作用。也可以简单的理解在 Java 的正则表达式中，两个\\\\ 代表其他语言中的一个\\，这也就是为什么表示一位数字的正则表达式是 \\\\d，而表示一个普通的反斜杠是 \\\\\\\\。 .1.7. 常用表达式匹配中文字符: System.out.println(Pattern.matches(&quot;[\\u4e00-\\u9fa5]&quot;, &quot;好&quot;)); 匹配Email地址 System.err.println(Pattern.matches(&quot;\\\\w[-\\\\w.+]*@([A-Za-z0-9][A-Za-z0-9]+\\\\.)+[A-Za-z]{2,14}&quot;, &quot;hello2020@qq.com&quot;)); m-n 位的数字 System.out.println(Pattern.matches(&quot;^\\\\d{1,3}$&quot;, &quot;123&quot;)); 密码必须由字母和数字组成，且长度要在6-12位之间 System.out.println(Pattern.matches(&quot;^(?![0-9]+$)(?![a-zA-Z]+$)[0-9A-Za-z]{6,12}$&quot;, &quot;123hello456&quot;)); 匹配时分秒 System.out.println(Pattern.matches(&quot;([01][0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9]&quot;, &quot;11:10:11&quot;)); IP地址格式 System.out.println(Pattern.matches(&quot;((2(5[0-5]|[0-4]\\\\d))|[0-1]?\\\\d{1,2})(\\\\.((2(5[0-5]|[0-4]\\\\d))|[0-1]?\\\\d{1,2})){3}&quot;, &quot;192.168.21.37&quot;)); 网址匹配包含http、https、ftp协议 System.out.println(Pattern.matches(&quot;^(https?|ftp)://[-a-zA-Z0-9+&amp;@#/%?=~_|!:,.;]*[-a-zA-Z0-9+&amp;@#/%=~_|]&quot;, &quot;http://www.bdqn.cn/&quot;)); .1.8. 两个例子匹配手机号 捕获组定义：把多个字符当一个单独单元进行处理的方法，它通过对括号内的字符分组来创建。 捕获组是通过从左至右计算其开括号来编号。例如，在表达式((A)(B(C)))，有四个这样的组： ((A)(B(C))) (A) (B(C)) (C) 可以通过调用 matcher 对象的 groupCount 方法来查看表达式有多少个分组。groupCount 方法返回一个 int 值，表示matcher对象当前有多个捕获组。另外还有一个特殊的组（group(0)），它总是代表整个表达式。该组不包括在 groupCount 的返回值中。","link":"/2020/05/07/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"}],"tags":[{"name":"Git","slug":"Git","link":"/tags/Git/"},{"name":"hexo","slug":"hexo","link":"/tags/hexo/"},{"name":"java","slug":"java","link":"/tags/java/"},{"name":"python","slug":"python","link":"/tags/python/"},{"name":"算法","slug":"算法","link":"/tags/%E7%AE%97%E6%B3%95/"}],"categories":[]}
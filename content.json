{"pages":[],"posts":[{"title":"Git学习笔记","text":"git大概是每个程序员必须要掌握的工具之一 常用 版本回退 避免重复劳动 分支 打包 本地与远程 常用git init ——初始化，创建git仓库git add filename ——添加文件git commit -m “日志说明” ——提交文件git log / git log –pretty=onelinegit reset –hard commit_id ——回滚到指定版本git reflog ——命令历史git checkout – filename ——工作区撤销，与暂存区相同git reset HEAD filename——暂存区file撤回到工作区git rm filename ——删除文件 版本回退HEAD指向的版本就是当前版本，因此，Git允许我们在版本的历史之间穿梭，使用命令git reset –soft/–mixed/–hard id回退，用git log可以查看提交历史重返未来，用git reflog查看命令历史 避免重复劳动在master分支上修复的bug，想要合并到当前dev分支，可以用git cherry-pick commit命令，把bug提交的修改“复制”到当前分支 分支查看分支：git branch创建分支：git branch name切换分支：git checkout name*或者git switch *name创建+切换分支：git checkout -b name*或者git switch -c *name合并某分支到当前分支：git merge name删除分支：git branch -d name分支合并图：git log –graph –pretty=oneline–pretty=oneline（将每条信息放在一行）###打包git stash 打包现场git stash list 查看stashgit stash pop 回到工作现场 本地与远程关联一个远程库git remote add origin git@server-name:path/repo-name.git；git push -u origin master第一次推送master分支的所有内容git push origin master此后推送最新修改从本地推送分支，使用git push origin branch-name，如果推送失败，先用git pull抓取远程的新提交；在本地创建和远程分支对应的分支，使用git checkout -b branch-name origin/branch-name，本地和远程分支的名称最好一致；建立本地分支和远程分支的关联，使用git branch –set-upstream branch-name origin/branch-name；从远程抓取分支，使用git pull，如果有冲突，要先处理冲突。","link":"/2020/03/07/Git%E5%AD%A6%E4%B9%A0/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. dadada","link":"/2020/03/07/hello-world/"},{"title":"icarus主题配置","text":"本文转载自CSDN:Hexo+icarus主题配置Hexo Icarus配置和美化升级 美化等进阶功能攻略位置：https://blog.csdn.net/marvine/article/details/89816846攻略位置：https://blog.csdn.net/qq_36759224/article/details/85420403#font_colorFF0000___font_289 目录 主题文件结构 主题配置 修改内容详细页 添加网站访问量因为目前搭的博客是静态网页，所以添加网站访问量需要用到第三方工具具体见:不蒜子:搞定你的网站计数 主题文件结构1234567891011/includes/languages #用来配置国际化语言版本，里边包含各种个配置像的文本翻译。/layout #以ejs文件来定义各种含有配置信息调用的布局（绝大多数修改点的位置）/scripts #一些JS脚本/source /css #用来修改自定义样式，需要掌握一定的css语法。 /fonts #定义字体文件，可以修改博客字体 /images #本地调用的图片放这里 /js #一些js脚本（特效.js存放处） /404.html #自定义的公益404页面/_config.yml #YML数据串行化格式语言书写的配置文件（首先修改） 主题配置_config.yml是主题的配置文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180version: 2.3.0# 你的网站图标，可以搜索在线图标制作，并将其放在images文件夹中favicon: /images/favicons.ico# Path or URL to RSS atom.xmlrss: /atom.xml# 显示在导航栏左侧的网站logo，同样可以自己制作logo: /images/gen.svg# Open Graph metadata# https://hexo.io/docs/helpers.html#open-graphopen_graph: # Facebook App ID fb_app_id: # Facebook Admin ID fb_admins: # Twitter ID twitter_id: # Twitter site twitter_site: # Google+ profile link google_plus: # 导航栏navbar: #菜单（显示名称：对应文件夹） menu: 主页: / 归档: /archives 分类: /categories 标签: /tags 关于: /about # 导航栏右侧图标链接 links: My GitHub: icon: fab fa-github url: '你的gityhub地址'# Footer section link settingsfooter: # 页脚图标链接 links: Creative Commons: icon: fab fa-creative-commons url: 'https://creativecommons.org/' Attribution 4.0 International: icon: fab fa-creative-commons-by url: 'https://creativecommons.org/licenses/by/4.0/' Download on GitHub: icon: fab fa-github url: 'http://github.com/ppoffice/hexo-theme-icarus'# 文章显示设置article: # Code highlight theme # https://github.com/highlightjs/highlight.js/tree/master/src/styles #代码主题atom-one-light亮色，atom-one-dark暗色 highlight: atom-one-dark # 是否显示文章主图 thumbnail: true # 是否显示估算阅读时间 readtime: true# 搜索插件设置# http://ppoffice.github.io/hexo-theme-icarus/categories/Configuration/Search-Pluginssearch: # Name of the search plugin type: insight# 评论插件设置# http://ppoffice.github.io/hexo-theme-icarus/categories/Configuration/Comment-Pluginscomment: #可选valine，disqus（科学上网）等 # Name of the comment plugin #type: valine #app_id: 不为空 #app_key: 不为空 #notify: true #verify: true #placeholder: type: disqus shortname: 不能为空# 打赏功能# http://ppoffice.github.io/hexo-theme-icarus/categories/Donation/donate: - # 阿里巴巴支付宝 type: alipay # 二维码图片 qrcode: '/images/honbao.PNG' - # 微信 type: wechat # 二维码图片 qrcode: '/images/yjtp.png' -# 分享插件设置# http://ppoffice.github.io/hexo-theme-icarus/categories/Configuration/Share-Pluginsshare: # 插件类型，有多种，可选，自行百度 type: sharejs# Sidebar settings.# Please be noted that a sidebar is only visible when it has at least one widgetsidebar: # 左侧边栏设置 left: # 是否不随页面滚动 # http://ppoffice.github.io/hexo-theme-icarus/Configuration/Theme/make-a-sidebar-sticky-when-page-scrolls/ sticky: false # 右侧边栏设置 right: # 是否不随页面滚动 # http://ppoffice.github.io/hexo-theme-icarus/Configuration/Theme/make-a-sidebar-sticky-when-page-scrolls/ sticky: false# 边栏小部件设置# http://ppoffice.github.io/hexo-theme-icarus/categories/Widgets/widgets: - # 个人信息 type: profile # 部件位置（左） position: left # 作者名（字符串） author: 飞鱼 # 作者身份描述（字符串） author_title: Student # 作者当前居住地 location: China,Fujian # 头像（可用本地图片或网络图片链接） avatar: '/images/ava.png' # Email address for the Gravatar to be shown in the profile widget gravatar: # 关注我的链接，可设为你的GitHub主页 follow_link: 'https://github.com/yourname' # 个人介绍部件底部图标社交链接 social_links: Github: icon: fab fa-github url: 'https://github.com/yourname' Facebook: icon: fab fa-facebook url: 'https://facebook.com' Twitter: icon: fab fa-twitter url: 'https://twitter.com/yourname' RSS: icon: fas fa-rss url: / - # Widget name type: toc # Where should the widget be placed, left or right position: left - # 分类 type: category # 位置指定 position: left - # 标签云 type: tagcloud # 位置 position: right - # 近期文章 type: recent_posts # 位置 position: left - # 归档 type: archive # Where should the widget be placed, left or right position: right - # 标签 type: tag # Where should the widget be placed, left or right position: right - # 外部链接 type: links # Where should the widget be placed, left or right position: left # Links to be shown in the links widget links: Google: 'https://google.com' Baidu: 'https://baidu.com' 修改内容详细页Hexo-icarus主题的文章详情页默认与主页布局一致，皆为三栏布局，想将其改为两栏布局。打开/themes/icarus/layout/layout.ejs文件，添加col()函数到文件中： 12345678&lt;% function col(){ if(!is_post()){ return main_column_class(); } else{ return 'is-6-tablet is-6-desktop is-9-widescreen'; } } %&gt; 再section标签中做如下改动： 12345678910&lt;section class=&quot;section&quot;&gt; &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;columns&quot;&gt; &lt;!-- 将main_column_class() 改为 col() --&gt; &lt;div class=&quot;column &lt;%= col() %&gt; has-order-2 column-main&quot;&gt;&lt;%- body %&gt;&lt;/div&gt; &lt;%- partial('common/widget', { position: 'left' }) %&gt; &lt;%- partial('common/widget', { position: 'right' }) %&gt; &lt;/div&gt; &lt;/div&gt; &lt;/section&gt; 不难看出，上述改动的目的是将显示逻辑改为：若当前页面不是文章页面则直接采用原始设置，否则将文章栏放大。通过上面的修改，hexo server查看效果，发现文章详情页的文章栏确实放大了，但是右侧的部件栏并未消失，而是被挤出了屏幕外一部分，极不美观。 为了解决上述问题，还需修改/themes/icarus/layout/common/widget.ejs文件。将代码全选复制，再粘贴于末尾，做如下修改3处代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172&lt;% if (get_widgets(position).length &amp;&amp; !is_post()) { %&gt; &lt;!-- 修改 --&gt;&lt;% function side_column_class() { switch (column_count()) { case 2: return 'is-4-tablet is-4-desktop is-4-widescreen'; case 3: return 'is-4-tablet is-4-desktop is-3-widescreen'; } return '';} %&gt;&lt;% function visibility_class() { if (column_count() === 3 &amp;&amp; position === 'right') { return 'is-hidden-touch is-hidden-desktop-only'; } return '';} %&gt;&lt;% function order_class() { return position === 'left' ? 'has-order-1' : 'has-order-3';} %&gt;&lt;% function sticky_class(position) { return get_config('sidebar.' + position + '.sticky', false) ? 'is-sticky' : '';} %&gt;&lt;div class=&quot;column &lt;%= side_column_class() %&gt; &lt;%= visibility_class() %&gt; &lt;%= order_class() %&gt; column-&lt;%= position %&gt; &lt;%= sticky_class(position) %&gt;&quot;&gt; &lt;% get_widgets(position).forEach(widget =&gt; {%&gt; &lt;%- partial('widget/' + widget.type, { widget, post: page }) %&gt; &lt;% }) %&gt; &lt;% if (position === 'left') { %&gt; &lt;div class=&quot;column-right-shadow is-hidden-widescreen &lt;%= sticky_class('right') %&gt;&quot;&gt; &lt;% get_widgets('right').forEach(widget =&gt; {%&gt; &lt;%- partial('widget/' + widget.type, { widget, post: page }) %&gt; &lt;% }) %&gt; &lt;/div&gt; &lt;% } %&gt;&lt;/div&gt;&lt;% } %&gt;&lt;!-- 粘贴的部分 --&gt;&lt;% if (position === 'left' &amp;&amp; is_post()) { %&gt; &lt;!-- 修改，可选保留的栏 --&gt;&lt;% function side_column_class() { switch (column_count()) { case 2: return 'is-4-tablet is-4-desktop is-4-widescreen'; case 3: return 'is-4-tablet is-4-desktop is-3-widescreen'; } return '';} %&gt;&lt;% function visibility_class() { if (column_count() === 3 &amp;&amp; position === 'right') { return 'is-hidden-touch is-hidden-desktop-only'; } return '';} %&gt;&lt;% function order_class() { return position === 'left' ? 'has-order-3' : 'has-order-1'; &lt;!-- 修改 --&gt;} %&gt;&lt;% function sticky_class(position) { return get_config('sidebar.' + position + '.sticky', false) ? 'is-sticky' : '';} %&gt;&lt;div class=&quot;column &lt;%= side_column_class() %&gt; &lt;%= visibility_class() %&gt; &lt;%= order_class() %&gt; column-&lt;%= position %&gt; &lt;%= sticky_class(position) %&gt;&quot;&gt; &lt;% get_widgets(position).forEach(widget =&gt; {%&gt; &lt;%- partial('widget/' + widget.type, { widget, post: page }) %&gt; &lt;% }) %&gt; &lt;% if (position === 'left') { %&gt; &lt;div class=&quot;column-right-shadow is-hidden-widescreen &lt;%= sticky_class('right') %&gt;&quot;&gt; &lt;% get_widgets('right').forEach(widget =&gt; {%&gt; &lt;%- partial('widget/' + widget.type, { widget, post: page }) %&gt; &lt;% }) %&gt; &lt;/div&gt; &lt;% } %&gt;&lt;/div&gt;&lt;% } %&gt;","link":"/2020/03/08/icarus%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/"},{"title":"hexo学习笔记","text":"用hexo+github搭建完了自己这个特别特别简陋的博客，这篇是最近学到的hexo和markdown的用法 命令行 插入图片- [绝对路径](#绝对路径) - [相对路径](#相对路径) 标签插件（Tag Plugins） 模板设置 命令行hexo new draft name—-创建名为name的草稿hexo publish draft name—-移动到_post里/发表 插入图片绝对路径当Hexo项目中只用到少量图片时，可以将图片统一放在source/images文件夹中，通过markdown语法访问它们。 ![](/images/image.jpg)相对路径图片除了可以放在统一的images文件夹中，还可以放在文章自己的目录中。文章的目录可以通过配置_config.yml来生成。 post_asset_folder: true 之后，执行命令$ hexo new post_name，在source/_posts中会生成文章post_name.md和同名文件夹post_name。将图片资源放在post_name中，文章就可以使用相对路径引用图片资源了。 ![](image.jpg) 标签插件（Tag Plugins）标签插件和 Front-matter 中的标签不同，它们是用于在文章中快速插入特定内容的插件。 &lt;!--more--&gt;——–read more 123{% blockquote %}内容{% endblockquote %} ——–普通blockquote 123{% blockquote 书名, 作者 %}内容{% endblockquote %} ——–引用书本的blockquote 模板设置当我们使用命令 hexo new “title” 创建文章时，Hexo 会根据 /scaffolds/post.md 对新文章进行初始化 换言之，/scaffolds/post.md 就是新文章的 模板，所以我们可以修改它来适应自己的写作习惯 一个简单的示例如下： 1234title: {{ title }}date: {{ date }}tags: categories: 属性和属性值之间必须有一个空格，否则会解析错误","link":"/2020/03/06/hexo%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"title":"java反射与junit的结合应用","text":"软件构造第一次实验的FriendshipGraph需要自己写junit的测试，当需要测一个没有返回值的方法的时候（修改了类的变量），就需要用到反射机制来帮助测试。其实这实验我这样做就变得复杂了很多…..hhhhhh 获取class对象的方法 Class对象功能 field field constructor method 举个这次实验的栗子 获取class对象的方法获取Class对象的方式： Class.forName(“全类名”)：将字节码文件加载进内存，返回Class对象 多用于配置文件，将类名定义在配置文件中。读取文件，加载类 类名.class：通过类名的属性class获取 多用于参数的传递 对象.getClass()：getClass()方法在Object类中定义着。 多用于对象的获取字节码的方式 Class对象功能 获取功能12345678getFields()：获得某个类的所有的公共（public）的字段，包括父类中的字段。 getDeclaredFields()：获得某个类的所有声明的字段，即包括public、private和proteced，但是不包括父类的申明字段。gitDeclaredField(String name):获得某个类的名为name的字段getConstructors()getDeclaredConstructors()getMethods()getDeclaredMethods() field 设置值void set(Object obj, Object value) 获取值get(Object obj) 忽略访问权限修饰符的安全检查setAccessible(true):当字段修饰符为private时，我们需要加上 constructor 创建对象：T newInstance(Object… initargs) 如果使用空参数构造方法创建对象，操作可以简化：Class对象的newInstance方法 ( jdk10已经不推荐使用了？ ) method 执行方法：Object invoke(Object obj, Object… args) 获取方法名称：String getName:获取方法名 举个这次实验的栗子1234567891011public class Person { private String name; private List&lt;Person&gt; friends; public Person(String name) { this.name = name; this.friends=new ArrayList&lt;Person&gt;(); } public void addFriend(Person friend) { friends.add(friend); }} 下面，测试addFriend 123456789101112131415Person rachel = new Person(\"Rachel\");Person ross = new Person(\"Ross\");Person ben = new Person(\"Ben\");List&lt;Person&gt; testfriends=new ArrayList&lt;Person&gt;();testfriends.add(ross);testfriends.add(ben);rachel.addFriend(ross);rachel.addFriend(ben);Class personClass=Person.class;Field fieldfriends=personClass.getDeclaredField(\"friends\");fieldfriends.setAccessible(true);//忽略封装assertEquals(rachelfriends, fieldfriends.get(rachel));//重点！！ 这样，就完成了对addFriend的测试","link":"/2020/03/08/java%E5%8F%8D%E5%B0%84+junit/"},{"title":"java文件读写","text":"软件构造lab1中遇到了文件读写的问题，自己用的一种简单的相对寻址的方法，但是健壮性不足，只要文件改变位置，就会报错。在和同学讨论的时候发现了更好的方法，故记录在这里，方便查看 用软件构造的lab1目录结构举例：Lab1-XXX|– src|—|– P1|—|—|-&gt; MagicSquare.java|—|—|– txt|—|—|—|-&gt; 1.txt|—|—|—|-&gt; 2.txt|—|—|—|-&gt; …|—|—|—|-&gt; 5.txt eclipse的相对路径是相对.project而言的！！！ 基本方法//Java7的try-with-resources可以优雅关闭文件，异常时自动关闭文件；详细解读https://stackoverflow.com/a/12665271 读取文件12345678910111213String pathname = \"src/P1/txt/1.txt\";public boolean isLegalMagicSquare() {try(BufferedReader input=new BufferedReader( new FileReader(pathname))) { String line; while ((line = input.readLine()) != null) { // 一次读入一行数据 System.out.println(line); } } catch (IOException e) { e.printStackTrace(); }} 写入文件12345678910111213141516171819202122//方法1String pathname = \"src/P1/txt/1.txt\";public static void writeFile() { try { File writeName = new File(pathname); writeName.createNewFile(); // 创建新文件,有同名的文件的话直接覆盖 try (PrintWriter out=new PrintWriter( new FileWriter(writeName)) ) { out.println(\"方法1\"); // \\r\\n即为换行 } } catch (IOException e) { e.printStackTrace(); } }//方法2BufferedWriter out=new BufferedWriter( new FileWriter(writeName))out.write(\"方法1\\r\\n\"); // \\r\\n即为换行out.write(\"hhhh\\r\\n\"); // \\r\\n即为换行out.flush(); // 把缓存区内容压入文件 下面有三个进阶一丢丢的方法，也许可以帮助改进你的代码 改进1使用System.getProperty(&quot;key&quot;) key . user.name 用户的账户名称 user.home 用户的主目录 user.dir 用户的当前工作目录 12345String path1=System.getProperty(\"user.dir\");System.out.println(path1);输出:D:\\JavaWorkPlace\\test 改进2查询某类的.class文件所在目录 1234567891011String path1=MagicSquare.class.getResource(\"\").getPath();String path2=MagicSquare.class.getResource(\"/\").getPath();String path3=MagicSquare.class.getResource(\"/P1/txt\").getPath();System.out.println(path1);System.out.println(path2);System.out.println(path3);输出：/D:/JavaWorkPlace/test/bin/P1//D:/JavaWorkPlace/test/bin//D:/JavaWorkPlace/test/bin/P1/txt //前提这个文件夹得存在 改进3 查询某类的classloader所在目录 12345String path1=MagicSquare.class.getClassLoader().getResource(\"\").getPath();System.out.println(path1);输出：/D:/JavaWorkPlace/test/bin/","link":"/2020/03/13/java%E6%96%87%E4%BB%B6%E8%AF%BB%E5%86%99/"},{"title":"最大子数组问题","text":"算法导论第四章分治的第一个例题：最大子数组问题 $O(n^2)$暴力算法 $O(nlogn)$分治算法将数组array[low..high]分为array[low..mid]，array[mid+1..high]最大子数组array[i..j]所在位置必然在如下三种情况里：1.完全位于array[low..mid]2.完全位于array[mid+1..high]3.跨越mid （low&lt;i&lt;mid&lt;j&lt;high) 1,2为重复子问题3即寻找i，j使array[i..mid]，array[mid+1..j]分别最大 ： O(n)级别 递归方程：$$T(n)=2*T(n/2)+O(n)$$复杂度即$O(nlogn)$ $O(n)$线性算法推荐一个非常棒的博客：最大子数组的和问题–线性算法","link":"/2020/03/17/%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84%E9%97%AE%E9%A2%98/"},{"title":"java关于集合类的一点点探索","text":"对set集合的contains函数的运行机制有一点点小疑问以及探索 问题123456789//保证了a，b指向两个ID不同，内容相同的字符串String a=new String(\"v1\");String b=new String(\"v1\");HashSet&lt;String&gt; set=new HashSet&lt;String&gt;();set.add(a);System.out.println(set.contains(b));//结果true a,b两个String类指向的对象，id不同，内容相同，contains是如何判断这两个对象相同的？最开始以为是和equals方法有关系，于是做了一个小测试 123456789101112//简单的car类public class car { private String name;}//mainHashSet&lt;car&gt; s=new HashSet&lt;car&gt;();car a=new car(\"car1\");car b=new car(\"car1\");s.add(a);System.out.println(s.contains(b));//结果false 结果显然是false于是重写了car的equals方法（右键自动生成的。。。） 12345678910111213141516@Overridepublic boolean equals(Object obj) { if (this == obj) return true; if (obj == null) return false; if (getClass() != obj.getClass()) return false; car other = (car) obj; if (name == null) { if (other.name != null) return false; } else if (!name.equals(other.name)) return false; return true;} 但是运行main函数仍然显示false 看源码一层一层的找往里找 12345private transient HashMap&lt;E,Object&gt; map;//HashSet的contains方法public boolean contains(Object o) { return map.containsKey(o); } （害！HashSet其实是用HashMap实现的啊） 1234//HashMappublic boolean containsKey(Object key) { return getNode(hash(key), key) != null; } 1234static final int hash(Object key) { int h; return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);} 12345678910111213141516171819final Node&lt;K,V&gt; getNode(int hash, Object key) { Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k; if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp; (first = tab[(n - 1) &amp; hash]) != null) { if (first.hash == hash &amp;&amp; // always check firstnode ((k = first.key) == key || (key != null &amp;&amp;key.equals(k)))) return first; if ((e = first.next) != null) { if (first instanceof TreeNode) return ((TreeNode&lt;K,V&gt;)first).getTreeNod(hash, key); do { if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp; key.equals(k)))) return e; } while ((e = e.next) != null); } } return null;} 最终getNode方法里面找到了答案(4,5行)1.判断两个对象hashcode是否相同,2.判断两个对象是否“相同” （a==b||a.equals(b)) 解决问题回头再来看car类尝试看一下两个对象的哈希值是否一样 1234567car a=new car(\"car1\");car b=new car(\"car1\");System.out.println(b.hashCode());System.out.println(a.hashCode());//结果13110531352018699554 所以问题就在此，重写一下hashcode方法试试(之前已经重写了equals方法) 1234567@Overridepublic int hashCode() { final int prime = 31; int result = 1; result = prime * result + ((name == null) ? 0 : name.hashCode()); return result;} 再来测试car类 12345678System.out.println(b.hashCode());System.out.println(a.hashCode());s.add(a);System.out.println(s.contains(b));//结果30461403046140true 总结HashSet的contains判断两对象相同的方法：1.判断两个对象hashcode是否相同,2.判断两个对象是否“相同” （a==b||a.equals(b)) 所以！为正在使用的类重写hashCode和equals方法即可。","link":"/2020/03/20/java%E5%85%B3%E4%BA%8E%E9%9B%86%E5%90%88%E7%B1%BB%E7%9A%84%E4%B8%80%E7%82%B9%E7%82%B9%E6%8E%A2%E7%B4%A2/"},{"title":"Python通过对象名调用方法（对象名后加括号和参数）","text":"提前一周写完软件构造实验，hhh，打算把python捡一捡然后网上一个例子给看懵了 model = MNIST() # 声明一个对象 a = model(b) # 用对象去调用方法????????小朋友你是不是有很多问号？ 一顿搜索发现其实原因就在于这个类实现了call()方法 可调用对象可调用对象（callable），我们平时自定义的函数、内置函数和类都属于可调用对象，但凡是可以把一对括号()应用到某个对象身上都可称之为可调用对象，判断对象是否为可调用对象可以用函数 callable 如果在类中实现了 __call__ 方法，那么实例对象也将成为一个可调用对象， 举个栗子： 12345678910111213class Entity:'''调用实体来改变实体的位置。'''def __init__(self, size, x, y): self.x, self.y = x, y self.size = sizedef __call__(self, x, y): '''改变实体的位置''' self.x, self.y = x, ye = Entity(1, 2, 3) // 创建实例e(4, 5) //实例可以象函数那样执行，并传入x y值，修改对象的x y e(4,5)本质其实是e.__call__(4,5)所以 __call__ 在那些类的实例经常改变状态的时候会非常有效。更多厉害的用法可以参考Python call详解","link":"/2020/04/08/Python%E9%80%9A%E8%BF%87%E5%AF%B9%E8%B1%A1%E5%90%8D%E8%B0%83%E7%94%A8%E6%96%B9%E6%B3%95%EF%BC%88%E5%AF%B9%E8%B1%A1%E5%90%8D%E5%90%8E%E5%8A%A0%E6%8B%AC%E5%8F%B7%E5%92%8C%E5%8F%82%E6%95%B0%EF%BC%89/"}],"tags":[{"name":"Git","slug":"Git","link":"/tags/Git/"},{"name":"hexo","slug":"hexo","link":"/tags/hexo/"},{"name":"算法","slug":"算法","link":"/tags/%E7%AE%97%E6%B3%95/"},{"name":"java","slug":"java","link":"/tags/java/"},{"name":"python","slug":"python","link":"/tags/python/"}],"categories":[]}
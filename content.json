{"pages":[],"posts":[{"title":"Git学习笔记","text":"git大概是每个程序员必须要掌握的工具之一 常用 版本回退 避免重复劳动 分支 打包 本地与远程 常用git init ——初始化，创建git仓库git add filename ——添加文件git commit -m “日志说明” ——提交文件git log / git log –pretty=onelinegit reset –hard commit_id ——回滚到指定版本git reflog ——命令历史git checkout – filename ——工作区撤销，与暂存区相同git reset HEAD filename——暂存区file撤回到工作区git rm filename ——删除文件 版本回退HEAD指向的版本就是当前版本，因此，Git允许我们在版本的历史之间穿梭，使用命令git reset –soft/–mixed/–hard id回退，用git log可以查看提交历史重返未来，用git reflog查看命令历史 避免重复劳动在master分支上修复的bug，想要合并到当前dev分支，可以用git cherry-pick commit命令，把bug提交的修改“复制”到当前分支 分支查看分支：git branch创建分支：git branch name切换分支：git checkout name*或者git switch *name创建+切换分支：git checkout -b name*或者git switch -c *name合并某分支到当前分支：git merge name删除分支：git branch -d name 查看分支图git log –graph –decorate –oneline –simplify-by-decoration –all说明：–decorate 标记会让git log显示每个commit的引用(如:分支、tag等)–oneline 一行显示–simplify-by-decoration 只显示被branch或tag引用的commit–all 表示显示所有的branch，这里也可以选择，比如我指向显示分支ABC的关系，则将–all替换为branchA branchB branchC###打包git stash 打包现场git stash list 查看stashgit stash pop 回到工作现场 本地与远程关联一个远程库git remote add origin git@server-name:path/repo-name.git；git push -u origin master第一次推送master分支的所有内容git push origin master此后推送最新修改从本地推送分支，使用git push origin branch-name，如果推送失败，先用git pull抓取远程的新提交；在本地创建和远程分支对应的分支，使用git checkout -b branch-name origin/branch-name，本地和远程分支的名称最好一致；建立本地分支和远程分支的关联，使用git branch –set-upstream branch-name origin/branch-name；从远程抓取分支，使用git pull，如果有冲突，要先处理冲突。","link":"/2020/03/07/Git%E5%AD%A6%E4%B9%A0/"},{"title":"hexo学习笔记","text":"用hexo+github搭建完了自己这个特别特别简陋的博客，这篇是最近学到的hexo和markdown的用法 命令行 插入图片- [绝对路径](#绝对路径) - [相对路径](#相对路径) 标签插件（Tag Plugins） 模板设置 命令行hexo new draft name—-创建名为name的草稿hexo publish draft name—-移动到_post里/发表 插入图片绝对路径当Hexo项目中只用到少量图片时，可以将图片统一放在source/images文件夹中，通过markdown语法访问它们。 ![](/images/image.jpg)相对路径图片除了可以放在统一的images文件夹中，还可以放在文章自己的目录中。文章的目录可以通过配置_config.yml来生成。 post_asset_folder: true 之后，执行命令$ hexo new post_name，在source/_posts中会生成文章post_name.md和同名文件夹post_name。将图片资源放在post_name中，文章就可以使用相对路径引用图片资源了。 ![](image.jpg) 标签插件（Tag Plugins）标签插件和 Front-matter 中的标签不同，它们是用于在文章中快速插入特定内容的插件。 &lt;!--more--&gt;——–read more 123{% blockquote %}内容{% endblockquote %} ——–普通blockquote 123{% blockquote 书名, 作者 %}内容{% endblockquote %} ——–引用书本的blockquote 模板设置当我们使用命令 hexo new “title” 创建文章时，Hexo 会根据 /scaffolds/post.md 对新文章进行初始化 换言之，/scaffolds/post.md 就是新文章的 模板，所以我们可以修改它来适应自己的写作习惯 一个简单的示例如下： 1234title: {{ title }}date: {{ date }}tags: categories: 属性和属性值之间必须有一个空格，否则会解析错误","link":"/2020/03/06/hexo%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"title":"java关于集合类的一点点探索","text":"对set集合的contains函数的运行机制有一点点小疑问以及探索 问题123456789//保证了a，b指向两个ID不同，内容相同的字符串String a=new String(\"v1\");String b=new String(\"v1\");HashSet&lt;String&gt; set=new HashSet&lt;String&gt;();set.add(a);System.out.println(set.contains(b));//结果true a,b两个String类指向的对象，id不同，内容相同，contains是如何判断这两个对象相同的？最开始以为是和equals方法有关系，于是做了一个小测试 123456789101112//简单的car类public class car { private String name;}//mainHashSet&lt;car&gt; s=new HashSet&lt;car&gt;();car a=new car(\"car1\");car b=new car(\"car1\");s.add(a);System.out.println(s.contains(b));//结果false 结果显然是false于是重写了car的equals方法（右键自动生成的。。。） 12345678910111213141516@Overridepublic boolean equals(Object obj) { if (this == obj) return true; if (obj == null) return false; if (getClass() != obj.getClass()) return false; car other = (car) obj; if (name == null) { if (other.name != null) return false; } else if (!name.equals(other.name)) return false; return true;} 但是运行main函数仍然显示false 看源码一层一层的找往里找 12345private transient HashMap&lt;E,Object&gt; map;//HashSet的contains方法public boolean contains(Object o) { return map.containsKey(o); } （害！HashSet其实是用HashMap实现的啊） 1234//HashMappublic boolean containsKey(Object key) { return getNode(hash(key), key) != null; } 1234static final int hash(Object key) { int h; return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);} 12345678910111213141516171819final Node&lt;K,V&gt; getNode(int hash, Object key) { Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k; if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp; (first = tab[(n - 1) &amp; hash]) != null) { if (first.hash == hash &amp;&amp; // always check firstnode ((k = first.key) == key || (key != null &amp;&amp;key.equals(k)))) return first; if ((e = first.next) != null) { if (first instanceof TreeNode) return ((TreeNode&lt;K,V&gt;)first).getTreeNod(hash, key); do { if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp; key.equals(k)))) return e; } while ((e = e.next) != null); } } return null;} 最终getNode方法里面找到了答案(4,5行)1.判断两个对象hashcode是否相同,2.判断两个对象是否“相同” （a==b||a.equals(b)) 解决问题回头再来看car类尝试看一下两个对象的哈希值是否一样 1234567car a=new car(\"car1\");car b=new car(\"car1\");System.out.println(b.hashCode());System.out.println(a.hashCode());//结果13110531352018699554 所以问题就在此，重写一下hashcode方法试试(之前已经重写了equals方法) 1234567@Overridepublic int hashCode() { final int prime = 31; int result = 1; result = prime * result + ((name == null) ? 0 : name.hashCode()); return result;} 再来测试car类 12345678System.out.println(b.hashCode());System.out.println(a.hashCode());s.add(a);System.out.println(s.contains(b));//结果30461403046140true 总结HashSet的contains判断两对象相同的方法：1.判断两个对象hashcode是否相同,2.判断两个对象是否“相同” （a==b||a.equals(b)) 所以！为正在使用的类重写hashCode和equals方法即可。","link":"/2020/03/20/java%E5%85%B3%E4%BA%8E%E9%9B%86%E5%90%88%E7%B1%BB%E7%9A%84%E4%B8%80%E7%82%B9%E7%82%B9%E6%8E%A2%E7%B4%A2/"},{"title":"Python通过对象名调用方法（对象名后加括号和参数）","text":"提前一周写完软件构造实验，hhh，打算把python捡一捡然后网上一个例子给看懵了 model = MNIST() # 声明一个对象 a = model(b) # 用对象去调用方法????????小朋友你是不是有很多问号？ 一顿搜索发现其实原因就在于这个类实现了call()方法 可调用对象可调用对象（callable），我们平时自定义的函数、内置函数和类都属于可调用对象，但凡是可以把一对括号()应用到某个对象身上都可称之为可调用对象，判断对象是否为可调用对象可以用函数 callable 如果在类中实现了 __call__ 方法，那么实例对象也将成为一个可调用对象， 举个栗子： 12345678910111213class Entity:'''调用实体来改变实体的位置。'''def __init__(self, size, x, y): self.x, self.y = x, y self.size = sizedef __call__(self, x, y): '''改变实体的位置''' self.x, self.y = x, ye = Entity(1, 2, 3) // 创建实例e(4, 5) //实例可以象函数那样执行，并传入x y值，修改对象的x y e(4,5)本质其实是e.__call__(4,5)所以 __call__ 在那些类的实例经常改变状态的时候会非常有效。更多厉害的用法可以参考Python call详解","link":"/2020/04/08/Python%E9%80%9A%E8%BF%87%E5%AF%B9%E8%B1%A1%E5%90%8D%E8%B0%83%E7%94%A8%E6%96%B9%E6%B3%95%EF%BC%88%E5%AF%B9%E8%B1%A1%E5%90%8D%E5%90%8E%E5%8A%A0%E6%8B%AC%E5%8F%B7%E5%92%8C%E5%8F%82%E6%95%B0%EF%BC%89/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. dadada","link":"/2020/03/07/hello-world/"},{"title":"java反射与junit的结合应用","text":"软件构造第一次实验的FriendshipGraph需要自己写junit的测试，当需要测一个没有返回值的方法的时候（修改了类的变量），就需要用到反射机制来帮助测试。其实这实验我这样做就变得复杂了很多…..hhhhhh 获取class对象的方法 Class对象功能 field field constructor method 举个这次实验的栗子 获取class对象的方法获取Class对象的方式： Class.forName(“全类名”)：将字节码文件加载进内存，返回Class对象 多用于配置文件，将类名定义在配置文件中。读取文件，加载类 类名.class：通过类名的属性class获取 多用于参数的传递 对象.getClass()：getClass()方法在Object类中定义着。 多用于对象的获取字节码的方式 Class对象功能 获取功能12345678getFields()：获得某个类的所有的公共（public）的字段，包括父类中的字段。 getDeclaredFields()：获得某个类的所有声明的字段，即包括public、private和proteced，但是不包括父类的申明字段。gitDeclaredField(String name):获得某个类的名为name的字段getConstructors()getDeclaredConstructors()getMethods()getDeclaredMethods() field 设置值void set(Object obj, Object value) 获取值get(Object obj) 忽略访问权限修饰符的安全检查setAccessible(true):当字段修饰符为private时，我们需要加上 constructor 创建对象：T newInstance(Object… initargs) 如果使用空参数构造方法创建对象，操作可以简化：Class对象的newInstance方法 ( jdk10已经不推荐使用了？ ) method 执行方法：Object invoke(Object obj, Object… args) 获取方法名称：String getName:获取方法名 举个这次实验的栗子1234567891011public class Person { private String name; private List&lt;Person&gt; friends; public Person(String name) { this.name = name; this.friends=new ArrayList&lt;Person&gt;(); } public void addFriend(Person friend) { friends.add(friend); }} 下面，测试addFriend 123456789101112131415Person rachel = new Person(\"Rachel\");Person ross = new Person(\"Ross\");Person ben = new Person(\"Ben\");List&lt;Person&gt; testfriends=new ArrayList&lt;Person&gt;();testfriends.add(ross);testfriends.add(ben);rachel.addFriend(ross);rachel.addFriend(ben);Class personClass=Person.class;Field fieldfriends=personClass.getDeclaredField(\"friends\");fieldfriends.setAccessible(true);//忽略封装assertEquals(rachelfriends, fieldfriends.get(rachel));//重点！！ 这样，就完成了对addFriend的测试","link":"/2020/03/08/java%E5%8F%8D%E5%B0%84+junit/"},{"title":"java文件读写","text":"软件构造lab1中遇到了文件读写的问题，自己用的一种简单的相对寻址的方法，但是健壮性不足，只要文件改变位置，就会报错。在和同学讨论的时候发现了更好的方法，故记录在这里，方便查看 用软件构造的lab1目录结构举例：Lab1-XXX|– src|—|– P1|—|—|-&gt; MagicSquare.java|—|—|– txt|—|—|—|-&gt; 1.txt|—|—|—|-&gt; 2.txt|—|—|—|-&gt; …|—|—|—|-&gt; 5.txt eclipse的相对路径是相对.project而言的！！！ 一般路径最好写成 / /等价于\\\\ 例：D:/test/main.java 基本方法//Java7的try-with-resources可以优雅关闭文件，异常时自动关闭文件；详细解读https://stackoverflow.com/a/12665271 读取文件12345678910111213String pathname = \"src/P1/txt/1.txt\";public boolean isLegalMagicSquare() {try(BufferedReader input=new BufferedReader( new FileReader(pathname))) { String line; while ((line = input.readLine()) != null) { // 一次读入一行数据 System.out.println(line); } } catch (IOException e) { e.printStackTrace(); }} 写入文件12345678910111213141516171819202122//方法1String pathname = \"src/P1/txt/1.txt\";public static void writeFile() { try { File writeName = new File(pathname); writeName.createNewFile(); // 创建新文件,有同名的文件的话直接覆盖 try (PrintWriter out=new PrintWriter( new FileWriter(writeName)) ) { out.println(\"方法1\"); // \\r\\n即为换行 } } catch (IOException e) { e.printStackTrace(); } }//方法2BufferedWriter out=new BufferedWriter( new FileWriter(writeName))out.write(\"方法1\\r\\n\"); // \\r\\n即为换行out.write(\"hhhh\\r\\n\"); // \\r\\n即为换行out.flush(); // 把缓存区内容压入文件 下面有三个进阶一丢丢的方法，也许可以帮助改进你的代码 改进1使用System.getProperty(&quot;key&quot;) key . user.name 用户的账户名称 user.home 用户的主目录 user.dir 用户的当前工作目录 12345String path1=System.getProperty(\"user.dir\");System.out.println(path1);输出:D:\\JavaWorkPlace\\test 改进2查询某类的.class文件所在目录 1234567891011String path1=MagicSquare.class.getResource(\"\").getPath();String path2=MagicSquare.class.getResource(\"/\").getPath();String path3=MagicSquare.class.getResource(\"/P1/txt\").getPath();System.out.println(path1);System.out.println(path2);System.out.println(path3);输出：/D:/JavaWorkPlace/test/bin/P1//D:/JavaWorkPlace/test/bin//D:/JavaWorkPlace/test/bin/P1/txt //前提这个文件夹得存在 改进3 查询某类的classloader所在目录 12345String path1=MagicSquare.class.getClassLoader().getResource(\"\").getPath();System.out.println(path1);输出：/D:/JavaWorkPlace/test/bin/","link":"/2020/03/13/java%E6%96%87%E4%BB%B6%E8%AF%BB%E5%86%99/"},{"title":"java父类子类初始化顺序","text":"由Cannot reference 'FlightScheduleApp.sources' before supertype constructor has been called引发的思考 问题123456789101112131415161718192021public class BaseApp&lt;S,E&gt; { private final List&lt;S&gt; sources; private final List&lt;Location&gt; locations; private final List&lt;E&gt; entries; public BaseApp(List&lt;S&gt; sources, List&lt;Location&gt; locations, List&lt;E&gt; entries) { this.sources = sources; this.locations = locations; this.entries = entries; }}public class FlightScheduleApp extends BaseApp&lt;Plane, FlightEntry&gt; { private final List&lt;Plane&gt; sources=new ArrayList&lt;&gt;(); private final List&lt;Location&gt; locations=new ArrayList&lt;&gt;(); private final List&lt;FlightEntry&gt; entries=new ArrayList&lt;&gt;(); public FlightScheduleApp() { //Cannot reference 'FlightScheduleApp.sources' before supertype constructor has been called super(sources,locations,entries); }} 意思是在父类构函数初始化之前不能引用这个变量。 解决办法在子类这个变量前加上startic修饰符时，就不再报错。 猜想验证1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/** * 父类 */public class Base { static String sVar = getString(\"父类静态变量初始化\"); public String var = getString(\"父类非静态变量初始化\"); public Base() { System.out.println(\"父类构造函数 start\"); draw(\"父类调用draw方法\");//会调用子类覆盖后的方法，这里是null System.out.println(\"父类构造函数 end\"); } static String getString(String base) { System.out.println(base); return base; } public void draw(String string) { System.out.println(string); }}/** * 子类 */public class SubClass extends Base { public String var = getString(\"子类非静态变量初始化\"); private String subVar = getString(\"子类私有变量初始化\"); static String superVar = getString(\"子类静态变量初始化\"); SubClass() { System.out.println(\"子类构造函数start\"); draw(\"子类调用draw方法\"); System.out.println(\"子类构造函数end\"); } public void draw(String string) { System.out.println(string + subVar); } public static void main(String[] args) { new SubClass(); }} 结果 1234567891011父类静态变量初始化子类静态变量初始化 &lt;-----父类非静态变量初始化 &lt;-----父类构造函数 start父类调用draw方法null父类构造函数 end子类非静态变量初始化 &lt;-----子类私有变量初始化子类构造函数start子类调用draw方法子类初始化私有变量子类构造函数end 可以发现，父类构造函数初始化早于子类非静态变量的初始化，晚于子类静态变量的初始化,所以当我们需要把变量改为static","link":"/2020/04/24/java%E7%88%B6%E7%B1%BB%E5%AD%90%E7%B1%BB%E5%88%9D%E5%A7%8B%E5%8C%96%E9%A1%BA%E5%BA%8F/"},{"title":"最大子数组问题","text":"算法导论第四章分治的第一个例题：最大子数组问题 $O(n^2)$暴力算法 $O(nlogn)$分治算法将数组array[low..high]分为array[low..mid]，array[mid+1..high]最大子数组array[i..j]所在位置必然在如下三种情况里：1.完全位于array[low..mid]2.完全位于array[mid+1..high]3.跨越mid （low&lt;i&lt;mid&lt;j&lt;high) 1,2为重复子问题3即寻找i，j使array[i..mid]，array[mid+1..j]分别最大 ： O(n)级别 递归方程：$$T(n)=2*T(n/2)+O(n)$$复杂度即$O(nlogn)$ $O(n)$线性算法推荐一个非常棒的博客：最大子数组的和问题–线性算法","link":"/2020/03/17/%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84%E9%97%AE%E9%A2%98/"},{"title":"icarus主题配置","text":"本文转载自CSDN:Hexo+icarus主题配置Hexo Icarus配置和美化升级 美化等进阶功能攻略位置：https://blog.csdn.net/marvine/article/details/89816846攻略位置：https://blog.csdn.net/qq_36759224/article/details/85420403#font_colorFF0000___font_289 目录 主题文件结构 主题配置 修改内容详细页 添加网站访问量因为目前搭的博客是静态网页，所以添加网站访问量需要用到第三方工具具体见:不蒜子:搞定你的网站计数 主题文件结构1234567891011/includes/languages #用来配置国际化语言版本，里边包含各种个配置像的文本翻译。/layout #以ejs文件来定义各种含有配置信息调用的布局（绝大多数修改点的位置）/scripts #一些JS脚本/source /css #用来修改自定义样式，需要掌握一定的css语法。 /fonts #定义字体文件，可以修改博客字体 /images #本地调用的图片放这里 /js #一些js脚本（特效.js存放处） /404.html #自定义的公益404页面/_config.yml #YML数据串行化格式语言书写的配置文件（首先修改） 主题配置_config.yml是主题的配置文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180version: 2.3.0# 你的网站图标，可以搜索在线图标制作，并将其放在images文件夹中favicon: /images/favicons.ico# Path or URL to RSS atom.xmlrss: /atom.xml# 显示在导航栏左侧的网站logo，同样可以自己制作logo: /images/gen.svg# Open Graph metadata# https://hexo.io/docs/helpers.html#open-graphopen_graph: # Facebook App ID fb_app_id: # Facebook Admin ID fb_admins: # Twitter ID twitter_id: # Twitter site twitter_site: # Google+ profile link google_plus: # 导航栏navbar: #菜单（显示名称：对应文件夹） menu: 主页: / 归档: /archives 分类: /categories 标签: /tags 关于: /about # 导航栏右侧图标链接 links: My GitHub: icon: fab fa-github url: '你的gityhub地址'# Footer section link settingsfooter: # 页脚图标链接 links: Creative Commons: icon: fab fa-creative-commons url: 'https://creativecommons.org/' Attribution 4.0 International: icon: fab fa-creative-commons-by url: 'https://creativecommons.org/licenses/by/4.0/' Download on GitHub: icon: fab fa-github url: 'http://github.com/ppoffice/hexo-theme-icarus'# 文章显示设置article: # Code highlight theme # https://github.com/highlightjs/highlight.js/tree/master/src/styles #代码主题atom-one-light亮色，atom-one-dark暗色 highlight: atom-one-dark # 是否显示文章主图 thumbnail: true # 是否显示估算阅读时间 readtime: true# 搜索插件设置# http://ppoffice.github.io/hexo-theme-icarus/categories/Configuration/Search-Pluginssearch: # Name of the search plugin type: insight# 评论插件设置# http://ppoffice.github.io/hexo-theme-icarus/categories/Configuration/Comment-Pluginscomment: #可选valine，disqus（科学上网）等 # Name of the comment plugin #type: valine #app_id: 不为空 #app_key: 不为空 #notify: true #verify: true #placeholder: type: disqus shortname: 不能为空# 打赏功能# http://ppoffice.github.io/hexo-theme-icarus/categories/Donation/donate: - # 阿里巴巴支付宝 type: alipay # 二维码图片 qrcode: '/images/honbao.PNG' - # 微信 type: wechat # 二维码图片 qrcode: '/images/yjtp.png' -# 分享插件设置# http://ppoffice.github.io/hexo-theme-icarus/categories/Configuration/Share-Pluginsshare: # 插件类型，有多种，可选，自行百度 type: sharejs# Sidebar settings.# Please be noted that a sidebar is only visible when it has at least one widgetsidebar: # 左侧边栏设置 left: # 是否不随页面滚动 # http://ppoffice.github.io/hexo-theme-icarus/Configuration/Theme/make-a-sidebar-sticky-when-page-scrolls/ sticky: false # 右侧边栏设置 right: # 是否不随页面滚动 # http://ppoffice.github.io/hexo-theme-icarus/Configuration/Theme/make-a-sidebar-sticky-when-page-scrolls/ sticky: false# 边栏小部件设置# http://ppoffice.github.io/hexo-theme-icarus/categories/Widgets/widgets: - # 个人信息 type: profile # 部件位置（左） position: left # 作者名（字符串） author: 飞鱼 # 作者身份描述（字符串） author_title: Student # 作者当前居住地 location: China,Fujian # 头像（可用本地图片或网络图片链接） avatar: '/images/ava.png' # Email address for the Gravatar to be shown in the profile widget gravatar: # 关注我的链接，可设为你的GitHub主页 follow_link: 'https://github.com/yourname' # 个人介绍部件底部图标社交链接 social_links: Github: icon: fab fa-github url: 'https://github.com/yourname' Facebook: icon: fab fa-facebook url: 'https://facebook.com' Twitter: icon: fab fa-twitter url: 'https://twitter.com/yourname' RSS: icon: fas fa-rss url: / - # Widget name type: toc # Where should the widget be placed, left or right position: left - # 分类 type: category # 位置指定 position: left - # 标签云 type: tagcloud # 位置 position: right - # 近期文章 type: recent_posts # 位置 position: left - # 归档 type: archive # Where should the widget be placed, left or right position: right - # 标签 type: tag # Where should the widget be placed, left or right position: right - # 外部链接 type: links # Where should the widget be placed, left or right position: left # Links to be shown in the links widget links: Google: 'https://google.com' Baidu: 'https://baidu.com' 修改内容详细页Hexo-icarus主题的文章详情页默认与主页布局一致，皆为三栏布局，想将其改为两栏布局。打开/themes/icarus/layout/layout.ejs文件，添加col()函数到文件中： 12345678&lt;% function col(){ if(!is_post()){ return main_column_class(); } else{ return 'is-6-tablet is-6-desktop is-9-widescreen'; } } %&gt; 再section标签中做如下改动： 12345678910&lt;section class=&quot;section&quot;&gt; &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;columns&quot;&gt; &lt;!-- 将main_column_class() 改为 col() --&gt; &lt;div class=&quot;column &lt;%= col() %&gt; has-order-2 column-main&quot;&gt;&lt;%- body %&gt;&lt;/div&gt; &lt;%- partial('common/widget', { position: 'left' }) %&gt; &lt;%- partial('common/widget', { position: 'right' }) %&gt; &lt;/div&gt; &lt;/div&gt; &lt;/section&gt; 不难看出，上述改动的目的是将显示逻辑改为：若当前页面不是文章页面则直接采用原始设置，否则将文章栏放大。通过上面的修改，hexo server查看效果，发现文章详情页的文章栏确实放大了，但是右侧的部件栏并未消失，而是被挤出了屏幕外一部分，极不美观。 为了解决上述问题，还需修改/themes/icarus/layout/common/widget.ejs文件。将代码全选复制，再粘贴于末尾，做如下修改3处代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172&lt;% if (get_widgets(position).length &amp;&amp; !is_post()) { %&gt; &lt;!-- 修改 --&gt;&lt;% function side_column_class() { switch (column_count()) { case 2: return 'is-4-tablet is-4-desktop is-4-widescreen'; case 3: return 'is-4-tablet is-4-desktop is-3-widescreen'; } return '';} %&gt;&lt;% function visibility_class() { if (column_count() === 3 &amp;&amp; position === 'right') { return 'is-hidden-touch is-hidden-desktop-only'; } return '';} %&gt;&lt;% function order_class() { return position === 'left' ? 'has-order-1' : 'has-order-3';} %&gt;&lt;% function sticky_class(position) { return get_config('sidebar.' + position + '.sticky', false) ? 'is-sticky' : '';} %&gt;&lt;div class=&quot;column &lt;%= side_column_class() %&gt; &lt;%= visibility_class() %&gt; &lt;%= order_class() %&gt; column-&lt;%= position %&gt; &lt;%= sticky_class(position) %&gt;&quot;&gt; &lt;% get_widgets(position).forEach(widget =&gt; {%&gt; &lt;%- partial('widget/' + widget.type, { widget, post: page }) %&gt; &lt;% }) %&gt; &lt;% if (position === 'left') { %&gt; &lt;div class=&quot;column-right-shadow is-hidden-widescreen &lt;%= sticky_class('right') %&gt;&quot;&gt; &lt;% get_widgets('right').forEach(widget =&gt; {%&gt; &lt;%- partial('widget/' + widget.type, { widget, post: page }) %&gt; &lt;% }) %&gt; &lt;/div&gt; &lt;% } %&gt;&lt;/div&gt;&lt;% } %&gt;&lt;!-- 粘贴的部分 --&gt;&lt;% if (position === 'left' &amp;&amp; is_post()) { %&gt; &lt;!-- 修改，可选保留的栏 --&gt;&lt;% function side_column_class() { switch (column_count()) { case 2: return 'is-4-tablet is-4-desktop is-4-widescreen'; case 3: return 'is-4-tablet is-4-desktop is-3-widescreen'; } return '';} %&gt;&lt;% function visibility_class() { if (column_count() === 3 &amp;&amp; position === 'right') { return 'is-hidden-touch is-hidden-desktop-only'; } return '';} %&gt;&lt;% function order_class() { return position === 'left' ? 'has-order-3' : 'has-order-1'; &lt;!-- 修改 --&gt;} %&gt;&lt;% function sticky_class(position) { return get_config('sidebar.' + position + '.sticky', false) ? 'is-sticky' : '';} %&gt;&lt;div class=&quot;column &lt;%= side_column_class() %&gt; &lt;%= visibility_class() %&gt; &lt;%= order_class() %&gt; column-&lt;%= position %&gt; &lt;%= sticky_class(position) %&gt;&quot;&gt; &lt;% get_widgets(position).forEach(widget =&gt; {%&gt; &lt;%- partial('widget/' + widget.type, { widget, post: page }) %&gt; &lt;% }) %&gt; &lt;% if (position === 'left') { %&gt; &lt;div class=&quot;column-right-shadow is-hidden-widescreen &lt;%= sticky_class('right') %&gt;&quot;&gt; &lt;% get_widgets('right').forEach(widget =&gt; {%&gt; &lt;%- partial('widget/' + widget.type, { widget, post: page }) %&gt; &lt;% }) %&gt; &lt;/div&gt; &lt;% } %&gt;&lt;/div&gt;&lt;% } %&gt;","link":"/2020/03/08/icarus%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/"},{"title":"正则表达式","text":"正则表达式初学 .1. 正则表达式 .1.1. 非打印字符 .1.2. 特殊符 .1.3. 限定符 .1.4. 定位符 .1.5. 高级 .1.6. 在java中的特殊点 .1.7. 常用表达式 .1.8. 两个例子 .1.1. 非打印字符 特别字符 描述 \\f 匹配一个换页符。等价于 \\x0c 和 \\cL。 \\n 匹配一个换行符。等价于 \\x0a 和 \\cJ。 \\r 匹配一个回车符。等价于 \\x0d 和 \\cM。 \\s 匹配任何空白字符，包括空格、制表符、换页符等等。等价于[ \\f\\n\\r\\t\\v]。注意 Unicode 正则表达式会匹配全角空格符。 \\S 匹配任何非空白字符。等价于 [^ \\f\\n\\r\\t\\v]。 \\t 匹配一个制表符。等价于 \\x09 和 \\cI。 \\v 匹配一个垂直制表符。等价于 \\x0b 和 \\cK。 \\w 匹配字母或数字或下划线或汉字 等价于 [^A-Za-z0-9_] \\d 匹配数字 \\D 匹配非数字 .1.2. 特殊符 符号 含义 . 除\\n以外任意字符 ^ 当该符号在方括号表达式中使用时，表示不接受该方括号表达式中的字符集合 | 二选一 .1.3. 限定符1234567891011*+？{n}{n,}{n,m} 其中* +为贪婪的,会尽可能多的匹配字符 例: 匹配&lt;h1&gt;不啦不啦不啦&lt;/h1&gt; 匹配结果 &lt;.*&gt; 贪婪 不啦不啦不啦 &lt;.*?&gt; 非贪婪 .1.4. 定位符 字符 描述 ^ 匹配输入字符串开始的位置。如果设置了 RegExp 对象的 Multiline 属性，^ 还会与 \\n 或 \\r 之后的位置匹配。 $ 匹配输入字符串结尾的位置。如果设置了 RegExp 对象的 Multiline 属性，$ 还会与 \\n 或 \\r 之前的位置匹配。 \\b 匹配一个单词边界，即字与空格间的位置。 \\B 非单词边界匹配。 注:若要匹配一行文本开始处的文本，请在正则表达式的开始使用 ^ 字符。不要将 ^ 的这种用法与中括号表达式内的用法混淆。 若要匹配一行文本的结束处的文本，请在正则表达式的结束处使用 $ 字符。 例 Chapter RegExp 匹配章节标题 ^Chapter [1-9][0-9]{0,1}$ 匹配单词开头 \\bCha 匹配结尾 ter\\b 匹配中间字符 \\Bapt 但无法匹配apter(开头) .1.5. 高级 字符 描述 (pattern) 匹配 pattern 并获取这一匹配。所获取的匹配可以从产生的 Matches 集合得到，在VBScript 中使用 SubMatches 集合，在JScript 中则使用 $0…$9 属性。要匹配圆括号字符，请使用 ‘(‘ 或 ‘)‘。 (?:pattern) 匹配 pattern 但不获取匹配结果，也就是说这是一个非获取匹配，不进行存储供以后使用。这在使用 “或” 字符 (|) 来组合一个模式的各个部分是很有用。例如，industr(?:y|ies) 就是一个比 industry|industries更简略的表达式。 (?=pattern) 正向肯定预查（look ahead positive assert），在任何匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如，Windows(?=95|98|NT|2000)能匹配Windows2000中的Windows，但不能匹配Windows3.1中的Windows。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。 (?!pattern) 正向否定预查(negative assert)，在任何不匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如Windows(?!95|98|NT|2000)能匹配Windows3.1中的Windows，但不能匹配Windows2000中的Windows。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。 (?&lt;=pattern) 反向(look behind)肯定预查，与正向肯定预查类似，只是方向相反。例如，”`(?&lt;=95 (?&lt;!pattern) 反向否定预查，与正向否定预查类似，只是方向相反。例如”(?”能匹配”3.1Windows“中的”Windows“，但不能匹配”2000Windows“中的”Windows“。 .1.6. 在java中的特殊点在其他语言中（如Perl），\\\\ 表示：我想要在正则表达式中插入一个普通的（字面上的）反斜杠，请不要给它任何特殊的意义。 在 Java 中，\\\\ 表示：我要插入一个正则表达式的反斜线，所以其后的字符具有特殊的意义。 所以，在其他的语言中（如Perl），一个反斜杠\\ 就足以具有转义的作用，而在 Java 中正则表达式中则需要有两个反斜杠才能被解析为其他语言中的转义作用。也可以简单的理解在 Java 的正则表达式中，两个\\\\ 代表其他语言中的一个\\，这也就是为什么表示一位数字的正则表达式是 \\\\d，而表示一个普通的反斜杠是 \\\\\\\\。 .1.7. 常用表达式匹配中文字符: System.out.println(Pattern.matches(&quot;[\\u4e00-\\u9fa5]&quot;, &quot;好&quot;)); 匹配Email地址 System.err.println(Pattern.matches(&quot;\\\\w[-\\\\w.+]*@([A-Za-z0-9][A-Za-z0-9]+\\\\.)+[A-Za-z]{2,14}&quot;, &quot;hello2020@qq.com&quot;)); m-n 位的数字 System.out.println(Pattern.matches(&quot;^\\\\d{1,3}$&quot;, &quot;123&quot;)); 密码必须由字母和数字组成，且长度要在6-12位之间 System.out.println(Pattern.matches(&quot;^(?![0-9]+$)(?![a-zA-Z]+$)[0-9A-Za-z]{6,12}$&quot;, &quot;123hello456&quot;)); 匹配时分秒 System.out.println(Pattern.matches(&quot;([01][0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9]&quot;, &quot;11:10:11&quot;)); IP地址格式 System.out.println(Pattern.matches(&quot;((2(5[0-5]|[0-4]\\\\d))|[0-1]?\\\\d{1,2})(\\\\.((2(5[0-5]|[0-4]\\\\d))|[0-1]?\\\\d{1,2})){3}&quot;, &quot;192.168.21.37&quot;)); 网址匹配包含http、https、ftp协议 System.out.println(Pattern.matches(&quot;^(https?|ftp)://[-a-zA-Z0-9+&amp;@#/%?=~_|!:,.;]*[-a-zA-Z0-9+&amp;@#/%=~_|]&quot;, &quot;http://www.bdqn.cn/&quot;)); .1.8. 两个例子匹配手机号 捕获组定义：把多个字符当一个单独单元进行处理的方法，它通过对括号内的字符分组来创建。 捕获组是通过从左至右计算其开括号来编号。例如，在表达式((A)(B(C)))，有四个这样的组： ((A)(B(C))) (A) (B(C)) (C) 可以通过调用 matcher 对象的 groupCount 方法来查看表达式有多少个分组。groupCount 方法返回一个 int 值，表示matcher对象当前有多个捕获组。另外还有一个特殊的组（group(0)），它总是代表整个表达式。该组不包括在 groupCount 的返回值中。","link":"/2020/05/07/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"title":"可维护性的构造原理","text":"SOLID 原则提供了五条指导思想，如果我们遵从它们的话， 将可以显著的提升我们软件可维护性。 SRP 单一责任原则(The Single Responsibility Principle) 单一职责原则（SRP）声明：“引起类变化的因素永远不要多余一个”。这意味着你需要设计你的类，使得每个类都只有一个目的。这并不意味着每个类应该只有一个方法，而是说类中所有的方法都要与该类的主要功能相关。那些有多个职责的类，应该被分成新的类。 —- One class, one responsibility SRP是最简单的原则，却是最难做好的原则。 来个反例： OCP 开放封闭原则(The Open Closed Principle) 软件实体应该是： 对扩展开放 对修改封闭 这个原则是诸多面向对象编程原则中最抽象、最难理解的一个。 关键解决方案：抽象技术。 使用继承和组合来改变类的行为。 第一个栗子： 第二个例子：以书店销售书籍为例 书籍接口 12345public interface IBook{ public String getName(); public String getPrice(); public String getAuthor();} 小说类 1234567891011121314151617181920212223public class NovelBook implements IBook{ private String name; private int price; private String author; public NovelBook(String name,int price,String author){ this.name = name; this.price = price; this.author = author; } public String getAutor(){ return this.author; } public String getName(){ return this.name; } public int getPrice(){ return this.price; } } 客户端 1234567public class Client{ public static void main(Strings[] args){ IBook novel = new NovelBook(\"深入理解计算机系统\",100,\"CMU\"); System.out.println(\"书籍名字：\"+novel.getName()+\"书籍作者：\"+novel.getAuthor()+\"书籍价格：\"+novel.getPrice()); }} 接下来，到了世界读书日，书店打折，需要做出改变。有一下几种修改方法： 修改接口 IBook里添加方法getOffPrice() （接口应该是稳定且可靠，不应该经常发生改变） 修改实现类 NovelBook里将getPrice()方法修改为打折价格 （我们如果getPrice()方法中只需要读取书籍的打折前的价格呢？）NovelBook里再增加getOffPrice()方法 （DIP原则（后文会讲到）要求尽量用接口定义变量，只在具体实现类里新增方法，用接口定义的变量无法使用这个方法） 实现拓展类 增加一个OffNovelBook类继承NovelBook，重写getPrice()方法，修改为打折价格 123456789101112public class OffNovelBook extends NovelBook{ public OffNovelBook(String name,int price,String author){ super(name,price,author); } //覆写价格方法 public int getPrice(){ return this.price * 0.9; } } } LSP 里氏替换原则(The Liskov Substitution Principle) 两种定义： 如果对每一个类型为S的对象o1，都有类型为T的对象o2，使得以T定义的所有程序P在所有的对象o1都代换为o2，程序P的行为没有发生变化，那么类型S是类型T的子类型。 所有引用基类的地方必须透明的使用其子类的对象。（只要父类能出现的地方子类也可以出现，而且替换为子类不会产生任何错误或异常，但是反过来就不行，有子类出现的地方，父类未必就能适应。） 里氏替换原则的规范 LSP为良好的继承定义了规范： 子类必须完全实现父类的方法 子类可以有自己的个性 覆盖或实现父类的方法时输入参数可以被放大（反协变）（java会将此认作方法重载） 覆盖或实现父类的方法时输出结果可以被缩小（协变） ISP 接口分离原则(The Interface Segregation cPrinciple) 两种定义： Clients should not be forced to depend upon interfaces that they don’t use. 客户端不应该依赖它不需用的接口。 The dependency of one class to another one should depend on the smallest possible interface。类间的依赖关系应该建立在最小的接口上。 理解： 建立单一接口 ，不要建立庞大臃肿的接口，尽量细化接口，接口中的方法尽量少。也就是说，我们要为各个类建立专用的接口，而不要试图去建立一个很庞大的接口供所有依赖它的类去调用。 依赖几个专用的接口要比依赖一个综合的接口：系统的灵活性更高，可维护性更好 区别一下单一职责原则和接口分离原则： 单一职责原则注重的是职责；接口隔离原则注重对接口依赖的隔离。 单一职责原则主要是约束类；接口隔离原则主要约束接口 DIP 依赖转置原则(The Dependency Inversion Principle) 定义： High level modules should not depend upon low level modules,Both should depend upon abstractions.高层模块不应该依赖低层模块，两者都应该依赖抽象 Abstractions should not depend upon details.抽象不应该依赖细节 Details should depend upon abstracts.细节应该依赖抽象 在java中，抽象就是接口和抽象类，细节就是实现类，翻译过来就是： 模块间的依赖通过抽象发生，实现类之间不发生直接的依赖关系，其依赖关系是通过接口或抽象类产生的。 接口或抽象类不依赖实现类 实现类依赖接口或抽象类 一句话概括就是——“面向接口编程” 前人经验： 每个类尽量都有接口或者抽象类，或者抽象类和接口两都具备 变量的表面类型尽量是接口或者抽象类 任何类都不应该从具体类派生 尽量不要覆写基类的方法 如果基类是一个抽象类，而这个方法已经实现了，子类尽量不要覆写。类间依赖的是抽象，覆写了抽象方法，对依赖的稳定性会有一定的影响。 结合里氏替换原则使用","link":"/2020/05/18/%E5%8F%AF%E7%BB%B4%E6%8A%A4%E6%80%A7%E7%9A%84%E6%9E%84%E9%80%A0%E5%8E%9F%E7%90%86/"},{"title":"唐纳德 高德纳给年轻人的建议 Donald Knuth - My advice to young people","text":"转自学长的博客 From: Donald Knuth - My advice to young people (93/97) 译者: 李秋豪 原文Donald Knuth (b. 1938), American computing pioneer, is known for his greatly influential multi-volume work, ‘The Art of Computer Programming’, his novel ‘Surreal Numbers’, his invention of TeX and METAFONT electronic publishing tools and his quirky sense of humour. [Listener: Dikran Karagueuzian] TRANSCRIPT: If somebody said what advice would I give to a… a young person - they always ask that funny kind of a question. And… and I think one of the things that… is… that I would… that would sort of come first to me is this idea of, don’t just believe that because something is trendy, that it’s good. I’d probably go the other extreme where if… if something… if I find too many people adopting a certain idea I’d probably think it’s wrong or if, you know, if… if my work had become too popular I probably would think I had to change. This is, of course, ridiculous but… but I see the… I see the… the other side of it too… too often where people will… will do something against their own gut instincts because they think the community wants them to do it that way, so people will… will work on a certain… a certain subject even though they aren’t terribly interested in it because they think that they’ll get more prestige by working on it. I think you get more prestige by doing good science than by doing popular science because… because if… if you go with… with what you really think is… is important then it’s a higher chance that it really is important in the long run and it’s the long run which… which has the most benefit to the world. So… so usually when I’m… when I’m writing a book or… or publishing a book it’s… it’s different from books that have been done before because I feel there’s a need for such a book, not because that… there was somebody saying please write such a book, you know, or… or that other people have… have already done that… that kind of thing. So follow your own instincts it seems to me is better than follow the… the herd. I… my friend Peter Wegner told me in the ‘60s that I should, for Art of Computer Programming, I shouldn’t write the… I shouldn’t write the whole series first, I should… I should first write a… a reader’s digest of… of it and then expand on the parts afterwards. That would probably work for him better than… much better… but I… I work in a completely different way. I have to see… I have to see something to the point where I’ve surrounded it and… and, sort of, totally understood it before I’m comf… before I can write about it with any confidence and so that’s the… that’s the way I work, I don’t… I don’t want to write about a high level thing unless I’ve fully understood a low level thing. Other people have completely different strengths I… I know but… but for me, I… you know, I wrote a book about the… a few verses of the Bible, once I had… once I understood those verses and… and sort of everything I could find in the library about a small part of the Bible, all of a sudden I had firm pegs on which I could hang other knowledge about it. But if… but if I went through my whole life only under… without any… any in depth knowledge of any part then it all seems to be flimsy and… and to me doesn’t… doesn’t give me some satisfaction. Well the… the classic phrase is that liberal education is to learn something about everything and everything about something and… and I like this idea about learning everything about… about an area before you feel… if you don’t know something real solid then… then you never have… have enough confidence. A lot of times I’ll have to read through a lot of material just in order to write one sentence somehow because… because my sentence will then have… have… I’ll choose words that… that make it more convincing than if I… than if I’m… than if I really don’t have the knowledge it’ll somehow come out implicitly in… in my writing. These are little sort-of-vague thoughts that I have when reflecting over… over some of the directions that distinguish what I’ve done from what… what I’ve seen other people doing. 译文如果有人问到我会给年轻人什么建议——他们总是问这些好玩的问题，第一个浮现在我脑海中的想法就是不要认为主流的东西就好。我可能会有些极端，如果我发现很多人都接受一个观点，那我可能会认为它是错误的，比如我的某个成果变得很出名我就会想办法做一些改变。 当然，这听起来有些荒谬，但是我确实看到了很多例子——很多人会违背他们内心的直觉因为社区/大众希望他们那么做，所以他们都开始在一个他们并不感兴趣的领域下功夫以期得到更多的名誉。而我认为如果你研究“好的”科学而非“大众/受欢迎”的科学你才会得到更多的名誉。因为从长远来看，做你认为重要的事会更可能对这个世界产生最有益的影响。 通常当我出一本书的时候，这本书是不同于现存的书的——我出这本书是因为我认为有这个需要而非有人恭维我出这样的书或者因为别人已经写过此类的书。遵从你的内心而非主流大众。60年代我写《计算机程序设计艺术》的时候，我的朋友Peter Wegner告诉我应该先列出来读者的口味然后从这些点扩展而非直接写整个序章。这可能对他很有帮助，但是我完全不是这么想的——我必须对“圈出”的关键点完全理解才会有写下去的信心。 我不会写高层次的东西除非我完全理解了低层次的东西。我知道别人擅长的和我完全不同，我仅仅写出“圣经”的一小部分诗，当我完全理解这一小部分后，突然间我就能获得关于这一部分的其他知识。如果我的一生都没有得到深层次的知识，那对我来说是浅薄和不满足的。有句话说的很经典：素质教育是“通百艺,专一长”。我喜欢“专一长”这个说法。如果你不能对某个领域的知识掌握的非常牢固，你就不会有足够的信心。很多时候我查阅大量的资料仅仅是为了写出一句话，因为我希望我的语句足够有说服力而非我自己都不知道这句到底是怎么来的。 这大致就是我观察思考自己做过的和别人做过的事而产生的一些想法。","link":"/2020/05/23/Donald%20Knuth%20-%20My%20advice%20to%20young%20people/"},{"title":"log4j学习笔记（1）","text":"介绍在编写大型项目时，日志输出是极其重要的一部分。而在Java项目中，常用的日志则是log4j和slf4j的组合。 log4jLog For Java，Apache的一个开源项目，可以灵活地记录日志信息，我们可以通过log4j的配置文件灵活配置日志的记录格式、记录级别、输出格式，而不需要修改已有的日志记录代码。 官方网站：http://logging.apache.org/log4j/1.2/ slf4j简单日志门面（Simple Logging Facade for Java），不是具体的日志解决方案，它只服务于各种各样的日志系统。按照官方的说法，slf4j是一个用于日志系统的简单Facade，允许最终用户在部署其应用时使用其所希望的日志系统。 在使用slf4j的时候，不需要在代码中或配置文件中指定你打算使用那个具体的日志系统，slf4j提供了统一的记录日志的接口，只要按照其提供的方法记录即可，最终日志的格式、记录级别、输出方式等通过具体日志系统的配置来实现，因此可以在应用中灵活切换日志系统。 官方网站：http://www.slf4j.org/ 先从log4j学起 log4j的使用配置文件可以有两种配置方式：log4j.properties（键对的形式）， log4j.xml .properties 123456789101112131415//定义两个INFO级别的appenderlog4j.rootLogger = INFO,console,logFile//org.apache.log4j.ConsoleAppender 输出到控制台log4j.appender.console = org.apache.log4j.ConsoleAppenderlog4j.appender.console.layout=org.apache.log4j.PatternLayoutlog4j.appender.console.layout.ConversionPattern=%d %p [%c] - &lt;%m&gt;%n//org.apache.log4j.FileAppender 输出到一个log文件//org.apache.log4j.DailyRollingFileAppender 每天自动产生一个日志文件log4j.appender.logFile = org.apache.log4j.FileAppenderlog4j.appender.logFile.File=src/log/logging.loglog4j.appender.logFile.Append=false //是否追加log4j.appender.logFile.layout=org.apache.log4j.PatternLayoutlog4j.appender.logFile.layout.ConversionPattern=%d %p [%c] - &lt;%m&gt;%n .xml 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE log4j:configuration SYSTEM \"log4j.dtd\"&gt;&lt;log4j:configuration&gt; &lt;!--若干个appender的定义--&gt; &lt;!--org.apache.log4j.ConsoleAppender 输出到控制台--&gt; &lt;appender name=\"myConsole\" class=\"org.apache.log4j.ConsoleAppender\"&gt; &lt;!--输出格式--&gt; &lt;layout class=\"org.apache.log4j.PatternLayout\"&gt; &lt;param name=\"ConversionPattern\" value=\"%-d{yyyy-MM-dd HH:mm:ss,SSS} [%c]-[%p] %m%n\"/&gt; &lt;/layout&gt; &lt;/appender&gt; &lt;!--org.apache.log4j.DailyRollingFileAppender 每天产生一个日志文件--&gt; &lt;appender name=\"myFile\" class=\"org.apache.log4j.DailyRollingFileAppender\"&gt; &lt;param name=\"File\" value=\"output.log\"/&gt;&lt;!--文件位置--&gt; &lt;param name=\"Append\" value=\"true\"/&gt;&lt;!--是否选择追加--&gt; &lt;layout class=\"org.apache.log4j.PatternLayout\"&gt; &lt;param name=\"ConversionPattern\" value=\"%-d{yyyy-MM-dd HH:mm:ss,SSS} [%c]-[%p] %m%n\"/&gt; &lt;/layout&gt; &lt;/appender&gt; &lt;!--org.apache.log4j.RollingFileAppender 滚动日志文件输出 文件大小到达一定尺寸时重新产生新的文件--&gt; &lt;!--&lt;appender name=\"myFile\" class=\"org.apache.log4j.RollingFileAppender\"&gt; &lt;param name=\"File\" value=\"D:/output.log\" /&gt; &lt;param name=\"Append\" value=\"true\" /&gt; &lt;param name=\"MaxFileSize\" value=\"500KB\"/&gt; &lt;param name=\"MaxBackupIndex\" value=\"10\" /&gt; &lt;layout class=\"org.apache.log4j.PatternLayout\"&gt; &lt;param name=\"ConversionPattern\" value=\"%p (%c:%L)- %m%n\" /&gt; &lt;/layout&gt; &lt;/appender&gt;--&gt; &lt;!--将各个包中的类日志输出到不同的日志文件中 这样可以便于日志的分类。 可以通过这个设置，把业务逻辑的日志添加到数据库。起到过滤的作用 --&gt; &lt;!--这段配置的就是说把包名为“com.zjut.a1”且优先级为debug的日志通过myFile这个appender来处理。 --&gt; &lt;category name=\"com.zjut.a1\"&gt; &lt;priority value=\"debug\"/&gt; &lt;appender-ref ref=\"myFile\"/&gt; &lt;/category&gt; &lt;!-- 根logger的设置--&gt; &lt;root&gt; &lt;!--优先级设置，假设设置为“info”，则无法输出debug级别的日志--&gt; &lt;priority value=\"debug\"/&gt; &lt;!--&lt;priority value=\"info\"/&gt;--&gt; &lt;!--&lt;priority value=\"warn\"/&gt;--&gt; &lt;!--&lt;priority value=\"error\"/&gt;--&gt; &lt;!--&lt;priority value=\"fatal\"/&gt;--&gt; &lt;!--添加刚才设置的appender--&gt; &lt;appender-ref ref=\"myConsole\"/&gt; &lt;appender-ref ref=\"myFile\"/&gt; &lt;/root&gt;&lt;/log4j:configuration&gt; 配置文件存放位置放在src下，不能是src下面的任一个文件夹下。 否则会报如下错 123log4j:WARN No appenders could be found for logger (org.apache.ibatis.logging.LogFactory).log4j:WARN Please initialize the log4j system properly.log4j:WARN See http://logging.apache.org/log4j/1.2/faq.html#noconfig for more info. 说明缺少log4j.properties这个文件或者他的存放的位置错误，导致找不到它。 还有另一个比较高阶的办法： 12345678910111213141516171819202122232425//手动配置public static void initLog() { FileInputStream fileInputStream = null; try { Properties properties = new Properties(); fileInputStream = new FileInputStream(\"src/log/log4j.properties\"); properties.load(fileInputStream); PropertyConfigurator.configure(properties); } catch (Exception e) { e.printStackTrace(); } finally { if (fileInputStream != null) { try { fileInputStream.close(); } catch (IOException e) { e.printStackTrace(); } } } }//在用logger之前，先initLog即可public static void main(String[] args) { initLog(); Logger logger=LogManager.getLogger(Mylog.class); } 日志输出级别log4j的日志级别如下表所示，其种从上至下等级越来越高，及配置了某一级别后，表格中处于它下边的位置级别的日志都会打印。 日志级别 说明 ALL 打印所有级别的日志 TRACE 指定细粒度比DEBUG更低的信息事件 DEBUG 指定细粒度信息事件是最有用的应用程序调试 INFO 指定能够突出在粗粒度级别的应用程序运行情况的信息的消息 WARN 指定具有潜在危害的情况 ERROR 错误事件可能仍然允许应用程序继续运行 FATAL 指定非常严重的错误事件，这可能导致应用程序中止 OFF 这是最高等级，为了关闭日志记录 ConversionPattern参数的格式含义log4j.appender.logFile.layout.ConversionPattern=%d %p [%c] - &lt;%m&gt;%n%c 输出日志信息所属的类的全名%d (datetime)输出日志时间点的日期或时间，默认格式为ISO8601，也可以在其后指定格式，比如：%d{yyy-MM-dd HH:mm:ss }，输出类似：2002-10-18- 22：10：28%F 输出日志信息所属的类的类名%L 输出日志事件的发生位置，即输出日志信息的语句处于它所在的类的第几行%m 输出代码中指定的信息，如log(message)中的message%n(new line) 输出一个回车换行符，Windows平台为“rn”，Unix平台为“n”%p (priority) 输出优先级，即DEBUG，INFO，WARN，ERROR，FATAL。如果是调用debug()输出的，则为DEBUG，依此类推%r (runtime) 输出自应用启动到输出该日志信息所耗费的毫秒数%t 输出产生该日志事件的线程名 使用使用起来可以说是简单了 1234567public static void main(String[] args) { //initLog(); //手动配置 Logger logger=LogManager.getLogger(Mylog.class); logger.info(\"info\"); logger.warn(\"warning\"); } 结果 slf4j待补充","link":"/2020/05/31/log4j%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(1)/"},{"title":"软件构造复习要点（一）","text":"1,2,3章 Five key quality objectives of software construction – Easy to understand: elegant and beautiful code / understandability – Ready for change: maintainability and adaptability – Cheap for develop: design for/with reuse: reusability – Safe from bugs: robustness – Efficient to run: performance How OOP improves qualityCorrectness: encapsulation, decentralization Robustness: encapsulation, error handling Extendibility: encapsulation, information hiding Reusability: modularity, component, models, patterns Compatibility: standardized module and interface Portability: information hiding, abstraction Ease of use: GUI components, framework Efficiency: reusable components Timeliness: modeling, reuse Economy: reuse Functionality: extendibility Static Typing vs. Dynamic Typing静态类型语言 – 在编译阶段进行类型检查 动态类型语言 – 在运行阶段进行类型检查 Static Checking and Dynamic Checking静态检查：关于“类型”的检查，不考虑值 动态检查：关于“值”的检查 静态类型检查 &gt;&gt; 动态 &gt;&gt; 无检查 静态类型检查：可在编译阶段发现错误，避 免了将错误带入到运行阶段，可提高程序正 确性/健壮性 Static checkingSyntax errors 语法错误 Wrong names 类名/函数名错误 Wrong number of arguments 参数数目错误 Wrong argument types 参数类型错误 Wrong return types 返回值类型错误 补充：如果编译器无法确定final变量不会改变，就提示错误，这也是静态类型检查的一部分 Dynamic checkingIllegal argument values 非法的参数值. 例如：除0 Unpresentable return values 非法的返回值 Out-of-range indexes 越界 Calling a method on a null object reference. 空指针 Immutable Wrappers– Collections.unmodifiableList – Collections.unmodifiableSet – Collections.unmodifiableMap 这种包装器得到的结果是不可变的：只能看 但是这种“不可变”是在运行阶段获得的，编译阶段 无法据此进行静态检查 所以如果对这种类型变量来 sort() ，java不会warn ，会在运行的时候报 exception ADTSpec除非spec的后置条件中有说明，否则方法不应该修改输入参数 spec变强：更放松的前置条件+更严格的后置条件 越强的规约，意味着implementer的自由度和责任越重，而client的 责任越轻。 Diagramming specifications某个具体实现， 若满足规约，则落在其范围内；否则，在其之外。 更强的规约，表达为更小的区域 ADT operationscreator : t* → T producer : T+, t* → T observer : T+, t* → t mutator : T+, t* → void | t | T 注： Each T is the abstract type itself Each t is some other type. 举例： 操作 类型 Integer.valueOf() Creator String.toUpperCase() Producer BufferedReader.readLine() Mutator ！！！ Map.keySet() Observer ！！！ how to establish invariantsestablished by creators and producers(创建要合法，checkRep) preserved by mutator and observers(修改要合法，checkRep) no representation exposure occurs (没有表示暴漏) Override &amp; Overload重写(Override)即外壳不变，核心重写！重载(Overload)方法名字相同，而参数不同, 相同/不同的返回值类型 相同/不同的public/private/protected 区别：Override 在运行阶段时决定执行哪个方法 (dynamic type checking)Overload 在编译阶段时决定执行哪个方法 (static type checking) Equality of ADTEquality of Immutable Types看AF： AF映射到同样的结果，则等价 看observation：站在外部观察者角度，对两个对象调用任何相同的操作，都会得到相同的结果，则认为这 两个对象是等价的。 观察等价性和行为等价性对Immutable Types来说等价 Equality of mutable Types行为等价性：调用对象的任何方法都展示出一致的结果（很严格）；接近于==；object的equals就是按照行为等价性 java中 set实现观察等价性 Equality contract用“是否为等价关系”检验你的equals()是否正确，如下： Reflexive – every object is equal to itself Symmetric – if a.equals(b) then b.equals(a) Transitive – if a.equals(b) and b.equals(c), then a.equals(c) Consistent– equal objects stay equal unless mutated “Non-null” – a.equals(null) returns false hashcode contract等价的对象，hashCode()必须相同 SoSo immutable types must override both equals() and hashCode() . So mutable types should not override equals() and hashCode() at all, Autoboxing and Equality观察下面现象 1234567Map&lt;String,Integer&gt; a=new HashMap&lt;&gt;();Map&lt;String,Integer&gt; b=new HashMap&lt;&gt;();a.put(\"c\", 1);b.put(\"c\", 1);System.out.print(a.get(\"c\")==b.get(\"c\"));result： true 1234567Map&lt;String,Integer&gt; a=new HashMap&lt;&gt;();Map&lt;String,Integer&gt; b=new HashMap&lt;&gt;();a.put(\"c\", 130);b.put(\"c\", 130);System.out.print(a.get(\"c\")==b.get(\"c\"));result： false 为什么！ -128~127，java内存中提前new好了，每次自动Autoboxing 的时候都去指向它们。 不是Autoboxing，当然不会这样 1234567Map&lt;String,Integer&gt; a=new HashMap&lt;&gt;();Map&lt;String,Integer&gt; b=new HashMap&lt;&gt;();a.put(\"c\", new Integer(13));b.put(\"c\", new Integer(13));System.out.print(a.get(\"c\")==b.get(\"c\"));result： false","link":"/2020/06/09/%E8%BD%AF%E4%BB%B6%E6%9E%84%E9%80%A0%E5%A4%8D%E4%B9%A0%E8%A6%81%E7%82%B9%EF%BC%88%E4%B8%80%EF%BC%89/"},{"title":"软件构造复习要点（一）","text":"4，5，6，7章 Levels reusable components源代码级别的复用– Requirements 需求 – Design and specifications 设计/规约spec – Data 数据 – Test cases 测试用例 – Documentation 文档 白盒复用：源代码可见，可修改和扩展 复制已有代码当正在开发的系统，进行修改 可定制化程度高 黑盒复用：源代码不可见，不能修改 只能通过API接口来使用，无法修改代码 简单，清晰 适应性差些 模块级别的复用：类/抽象类/接口Approaches of reusing a class: inheritance继承 delegation委托 库级别的复用：API/包系统级别的复用：框架框架：一组具体类、抽象类、及其之间的连接关系 白盒框架，通过代码层面的继承进行框架扩展 黑盒框架，通过实现特定接口/delegation进行 框架扩展 External observations of reusability1. Type Variation 类型可变 泛型 2. Routine Grouping 功能分组 提供完备的细粒度操作，保证功能的完整性，不同场景下复用不同的 操作(及其组合) 3. Implementation Variation 实现可变 ADT有多种不同的实现，提供不同的representations和 abstract function，但具有同样的specification (pre-condition, postcondition, invariants)，从而可以适应不同的应用场景 4. Representation Independence 表示独立 内部实现可能会经常变化，但客户端不应受到影响。 表示独立性、信息隐藏 5. Factoring Out Common Behaviors 共性抽取 将共同的行为（共性）抽象出来，形成可复用实体：父类、抽象类 Behavioral subtyping/LSP原则Compiler-enforced rules in Java (static type checking)Subtypes can add, but not remove methods 子类型可以增加方法，但不可删 Concrete class must implement all undefined methods 子类型需要实现抽象 类型中的所有未实现方法 Overriding method must return same type or subtype 子类型中重写的方法 必须有相同或子类型的返回值或者符合co-variance的参数 Overriding method must accept the same parameter types 子类型中重写的 方法必须使用同样类型的参数或者符合contra-vshuofaariance的参数（java不支持参数反协变，会当作重载） Overriding method may not throw additional exceptions 子类型中重写的方 法不能抛出额外的异常 LSP原则前置条件不能强化 后置条件不能弱化 不变量要保持 子类型方法参数：逆变 子类型方法的返回值：协变 异常类型：协变 Covariance (协变)返回值类型 &amp; 异常的类型：不变或变得更具体 Contravariance (反协变、逆变)参数类型：要相反的变化，要不变或越来越抽象（java不支持参数反协变，会当作重载） 应用中的例子123456789101112131415class Car{}class SmallCar extends Car{}public static void test(Car c) { System.out.print(\"car\");}public static void test(Object c) { System.out.print(\"object\");}public static void main(String []args){ test(new SmallCar());} *console :car * Generics 泛型LSP与泛型ArrayList&lt;String&gt;是List&lt;String&gt;的子类 List&lt;String&gt;不是List&lt;Object&gt;的子类 通配符&lt;? super Integer&gt; 可以接受 : Integer, Number, and Object &lt;? extends Number&gt;可以接受：Number和number的子类 Delegation and CompositionComposite Reuse Principle (CRP)在软件复用时，要尽量先使用组合或者聚合等关联关系来实现，其次才考虑使用继承关系来实现。 如果要使用继承关系，则必须严格遵循里氏替换原则。合成复用原则同里氏替换原则相辅相成的，两者都是开闭原则的具体实现规范。 继承我们叫做白箱复用，相当于把所有的实现细节暴露给子类。 组合/聚合也称之为黑箱复用，对类以外的对象是无法获取到实现细节的。 Types of delegationDependency：临时性的delegation Association: 永久性的delegationComposition（组合）：更强的association，但难以变化 Aggregation（聚合）: 更弱的association，可动态变化 Design Patterns for ReuseStructural patternsAdapter将某个类/接口转换为client期望的其他形式 Decorator当需要特性的任意组合的时候，可以用装饰器模式 subtyping + delegation 抽象构件(Component)角色：给出一个抽象接口，以规范准备接收附加责任的对象。具体构件(ConcreteComponent)角色：定义一个将要接收附加责任的类装饰角色(Decorator)：持有一个构件(Component)对象的实例，并定义一个与抽象构件接口一致的接口具体装饰角色(ConcreteDecorator)：负责给构件对象“贴上”附加的责任 举个例子： 咖啡是一种饮料，咖啡的本质是咖啡豆+水磨出来的。咖啡店现在要卖各种口味的咖啡，如果不使用装饰模式，那么在销售系统中，各种不一样的咖啡都要产生一个类，如果有4中咖啡豆，5种口味，那么将要产生至少20个类（不包括混合口味），非常麻烦。使用了装饰模式，只需要11个类即可生产任意口味咖啡（包括混合口味）。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798public interface Beverage { //返回商品描述 public String getDescription(); //返回价格 public double getPrice();}//具体被装饰的对象类1public class CoffeeBean1 implements Beverage { private String description = \"选了第一种咖啡豆\"; @Override public String getDescription() { return description; } @Override public double getPrice() { return 50; }}//具体被装饰的对象类2public class CoffeeBean2 implements Beverage { private String description = \"第二种咖啡豆！\"; @Override public String getDescription() { return description; } @Override public double getPrice() { return 100; }}//装饰器public class Decorator implements Beverage { private String description = \"我只是装饰器，不知道具体的描述\"; @Override public String getDescription() { return description; } @Override public double getPrice() { return 0; //价格由子类来决定 }}public class Milk extends Decorator{ private String description = \"加了牛奶！\"; private Beverage beverage = null; public Milk(Beverage beverage){ this.beverage = beverage; } public String getDescription(){ return beverage.getDescription()+\"\\n\"+description; } public double getPrice(){ return beverage.getPrice()+20; //20表示牛奶的价格 }}public class Mocha extends Decorator { private String description = \"加了摩卡！\"; private Beverage beverage = null; public Mocha(Beverage beverage){ this.beverage = beverage; } public String getDescription(){ return beverage.getDescription()+\"\\n\"+description; } public double getPrice(){ return beverage.getPrice()+49; //30表示摩卡的价格 }}public class Soy extends Decorator { private String description = \"加了豆浆！\"; private Beverage beverage = null; public Soy(Beverage beverage){ this.beverage = beverage; } public String getDescription(){ return beverage.getDescription()+\"\\n\"+description; } public double getPrice(){ return beverage.getPrice()+30; //30表示豆浆的价格 }}//testpublic class Test { public static void main(String[] args) { Beverage beverage = new CoffeeBean1(); //选择了第一种咖啡豆磨制的咖啡 beverage = new Mocha(beverage); //为咖啡加了摩卡 beverage = new Milk(beverage); //为咖啡加了牛奶 System.out.println(beverage.getDescription()+\"\\n加了摩卡和牛奶的咖啡价格：\"+beverage.getPrice()); }}//结果选了第一种咖啡店加入了摩卡！加入了牛奶！加了摩卡和牛奶的咖啡价格：119.0 重要的一点补充： 装饰模式对客户端的透明性要求程序不要声明一个ConcreteComponent类型的变量，而应当声明一个Component类型的变量。 用上面的例子来说，必须永远把所有的饮料当成饮料来对待，而如果把饮料变成的加摩卡的饮料当成摩卡，而不是饮料，这是不应当发生的。 Adapter和Decorator的关系装饰模式和适配器模式都是“包装模式(Wrapper Pattern)”，它们都是通过封装其他对象达到设计的目的的。 区别： 理想的装饰模式在对被装饰对象进行功能增强的同时，要求具体构件角色、装饰角色的接口与抽象构件角色的接口完全一致。 适配器模式并不要求对源对象的功能进行增强，但是会改变源对象的接口，以便和目标接口相符合。 拓展： 并且，装饰模式有透明和半透明两种，这两种的区别就在于装饰角色的接口与抽象构件角色的接口是否完全一致。 透明的装饰模式也就是理想的装饰模式。半透明的装饰器模式如下图： Facade 客户 端需要通过一个简化的接口来访问复杂系统内的功能 Behavioral patternsStrategy 为不同的实现算 法构造抽象接口，利用delegation，运行时动态传入client倾向的算法 类实例 Template共性的步骤在抽象类内公共实现，差 异化的步骤在各个子类中实现 inheritance + overridable Iterator对放入集合类里的ADT提供统一的遍历方法 Iterator 迭代器接口ConcreateIterator 具体实现类Aggregate 集合类接口ConcreteAggregate 具体的集合类 好处： 一个重要的原因，引入 Iterator 后可以将遍历与实现分离出来。 不论具体集合类如何实现（数组or链表），下面的遍历代码都不用改动 123while (iterator.hasNext()) { System.out.println(iterator.next().getName()); } 未完待续。。。 try-catch-finally 1234567891011public static boolean test() { try { return true; }finally { return false; }} public static void main(String []args) { System.out.print(test()); } return false","link":"/2020/06/12/%E8%BD%AF%E4%BB%B6%E6%9E%84%E9%80%A0%E5%A4%8D%E4%B9%A0%E8%A6%81%E7%82%B9%EF%BC%88%E4%BA%8C%EF%BC%89/"}],"tags":[{"name":"Git","slug":"Git","link":"/tags/Git/"},{"name":"hexo","slug":"hexo","link":"/tags/hexo/"},{"name":"java","slug":"java","link":"/tags/java/"},{"name":"python","slug":"python","link":"/tags/python/"},{"name":"其他","slug":"其他","link":"/tags/%E5%85%B6%E4%BB%96/"},{"name":"软件构造","slug":"软件构造","link":"/tags/%E8%BD%AF%E4%BB%B6%E6%9E%84%E9%80%A0/"},{"name":"数据结构与算法","slug":"数据结构与算法","link":"/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"工具学习","slug":"工具学习","link":"/tags/%E5%B7%A5%E5%85%B7%E5%AD%A6%E4%B9%A0/"}],"categories":[]}